<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Threadscape</title>
    <!-- Favicons / Icons -->
    <link
      rel="icon"
      type="image/png"
      sizes="1024x1024"
      href="./asset/threadscape/icon.png"
    />

    <!-- HEAD: import Material Symbols -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
    />
    <style>
      /* === FIGMA-LIKE RESTYLE (DARK) =================================== */

      /* Palette */
      :root {
        --bg: #0e0e0e;
        --panel: #151515;
        --panel-soft: #161616;
        --ink: #ffffff;
        --muted: #bdbdbd;
        --line: #2a2a2a;
        --btn-hover: rgba(255, 255, 255, 0.08);
        --btn-active: rgba(255, 255, 255, 0.12);
        --field: #1e1e1e;
        --field-hover: #222222;
        --field-focus-ring: rgba(255, 255, 255, 0.18);
        --chip: #1e1e1e;
        --chip-hover: #3f3f3f;
        --chip-active: #2f2f2f;
      }

      /* Reset selezione monocromatica */
      ::selection {
        background: rgba(255, 255, 255, 0.18);
        color: #fff;
      }
      ::-moz-selection {
        background: rgba(255, 255, 255, 0.18);
        color: #fff;
      }

      /* Material Symbols: leggermente più sottili ma nitide */
      .material-symbols-outlined {
        font-variation-settings: "FILL" 0, "wght" 200, "opsz" 24;
        font-size: 22px;
        line-height: 1;
        display: inline-block;
        vertical-align: middle;
      }

      /* Header sticky come Figma, ma senza bordo duro */
      header {
        position: sticky;
        top: 0;
        z-index: 5;
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 6px 8px;
        background: var(--bg);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }

      /* Icon button (toolbar): senza bordo; hover → bg leggero */
      header button,
      .icon-btn {
        appearance: none;
        -webkit-appearance: none;
        border: none;
        background: transparent;
        color: #eee;
        padding: 6px 8px;
        border-radius: 8px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        transition: background-color 120ms ease, opacity 120ms ease,
          transform 60ms ease;
      }
      header button:hover,
      .icon-btn:hover {
        background: var(--btn-hover);
      }
      header button:active,
      .icon-btn:active {
        background: var(--btn-active);
        transform: translateY(0.5px);
      }
      header button:focus-visible,
      .icon-btn:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px var(--btn-hover);
      }

      /* Stato "active" (es. connect attivo): bg continuo, niente bordo lampeggiante */
      button.connect.active {
        background: var(--btn-active);
        animation: none;
      }

      /* removed old CSS tooltip rules (data-tip) */

      /* App layout + sidebar più soft */
      .app {
        display: grid;
        grid-template-columns: 1fr 360px;
        grid-template-rows: 50px 1fr;
        height: 100vh;
      }
      .app header {
        grid-column: 1 / -1;
      }
      .app.no-panel {
        grid-template-columns: 1fr !important;
      }
      .app.no-panel aside {
        display: none !important;
      }

      aside {
        background: var(--panel-soft);
        border-left: 1px solid rgba(255, 255, 255, 0.06);
        padding: 10px;
        overflow: auto;
      }

      /* Stage e edges invariati */
      #stage {
        position: relative;
        overflow: hidden;
        background: var(--bg);
        background-image: linear-gradient(#111 1px, transparent 1px),
          linear-gradient(90deg, #111 1px, transparent 1px);
        background-size: 24px 24px, 24px 24px;
      }
      /* CSS da mettere nello <style> */
      .marquee-active *:not(input):not(textarea):not([contenteditable]) {
        user-select: none !important;
        -webkit-user-select: none !important;
      }
      svg#edges {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        z-index: 0;
      }

      /* Node card: bordo meno marcato, look pulito */
      .node {
        position: absolute;
        width: 320px;
        max-width: 400px;
        min-width: 260px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        background: var(--panel);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
        cursor: grab;
        transform-origin: top left;
      }
      .node.dragging {
        cursor: grabbing;
      }
      .node.selected {
        outline: 2px solid #fff;
      }

      /* Titlebar styles removed (title now lives inside .body) */
      .title {
        font-weight: 400;
        font-size: 12px;
        color: #fff;
        min-height: 1em;
      }
      .body {
        padding: 8px;
      }
      .meta {
        color: var(--muted);
        font-size: 12px;
      }
      .divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.06);
        margin: 6px 0;
      }

      /* Key/Value grid pulito */
      .kv {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 4px;
        font-size: 12px;
      }
      .kv div:nth-child(odd) {
        color: #bbb;
      }

      /* Description: campi testuali più leggibili */
      /* supporta accapo e linee vuote nei nodi */
      .desc {
        margin-top: 2px;
        font-size: 12px;
        white-space: pre-wrap;
      }

      .node .title,
      .node .meta,
      .node .kv,
      .node .desc,
      .node .links,
      .node .badge {
        overflow-wrap: break-word;
        word-break: break-word;
      }

      .desc > * {
        margin: 0;
      }
      .descTitle {
        margin-top: 4px;
        font-size: 12px;
        color: #bbb;
      }

      /* Links */
      .links {
        margin-top: 8px;
        font-size: 12px;
      }
      .links a {
        color: #fff;
        text-decoration: underline;
        display: inline-block;
        margin: 2px 10px 0 0;
      }

      /* Images/attachments invariati */
      .images {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .images img {
        display: block;
        width: 100%;
        height: auto;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        pointer-events: none;
        -webkit-user-drag: none;
        user-drag: none;
      }
      .attachments {
        margin-top: 8px;
        font-size: 12px;
      }
      .attachments a {
        color: #fff;
        text-decoration: underline;
        margin-right: 10px;
      }

      /* Handle più grandi ma visivamente come prima */
      .handle {
        position: absolute;
        width: 40px;
        height: 40px;
        pointer-events: auto;
      }
      .out {
        right: -22px;
        top: 50%;
        transform: translateY(-50%);
      }
      .in {
        left: -22px;
        top: 50%;
        transform: translateY(-50%);
      }
      .out::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        right: 13px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        border: 1px solid #000;
        border-radius: 50%;
      }
      .in::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        left: 13px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        border: 1px solid #000;
        clip-path: polygon(0% 0%, 100% 50%, 0% 100%);
      }

      /* Edges: già ottimizzati altrove; qui solo colori */
      .edge-visible {
        stroke: #e0e0e0;
        stroke-width: 2;
        fill: none;
        cursor: pointer;
        pointer-events: stroke;
      }
      .edge-visible.selected {
        stroke: #ffffff;
        stroke-width: 3;
      }
      .edge-visible.weak {
        stroke: #cfcfcf;
        stroke-opacity: 0.5;
        stroke-dasharray: 10 6;
        stroke-linecap: round;
        stroke-width: 1.5;
      }
      .edge-visible.weak.selected {
        stroke: #ffffff;
        stroke-opacity: 1;
        stroke-dasharray: 10 6;
        stroke-linecap: round;
        stroke-width: 2.5;
      }
      /* Se usi edge-hit, mantieni lo stile invisibile largo */
      .edge-hit {
        stroke: transparent;
        stroke-width: 24;
        fill: none;
        cursor: pointer;
        pointer-events: stroke;
      }

      /* Marquee coerente */
      .marquee {
        position: absolute;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.06);
        pointer-events: none;
        z-index: 2;
      }

      /* Sidebar: campi alla Figma-like (no border, bg chiaro, focus ring) */
      label {
        display: block;
        font-size: 12px;
        margin-top: 12px;
        color: #ddd;
      }
      input[type="text"],
      input[type="date"],
      textarea {
        width: 100%;
        background: var(--field) !important;
        border: none !important;
        color: #eee;
        padding: 8px 10px !important;
        border-radius: 8px !important;
        font-family: inherit;
        margin-top: 6px;
        transition: background-color 120ms ease, box-shadow 120ms ease;
      }
      input:hover,
      textarea:hover {
        background: var(--field-hover) !important;
      }
      input:focus,
      input:focus-visible,
      textarea:focus,
      textarea:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px var(--field-focus-ring) !important;
      }
      textarea {
        min-height: 140px;
        resize: vertical;
      }
      input::placeholder,
      textarea::placeholder {
        color: #9a9a9a;
      }

      /* Date input levigato */
      input[type="date"] {
        caret-color: #eee;
      }
      input[type="date"]::-webkit-calendar-picker-indicator {
        filter: grayscale(100%);
        opacity: 0.9;
      }

      /* File list */
      .file-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 12px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      .file-left {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }
      .thumb {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid #333;
        object-fit: cover;
        display: block;
      }
      .file-row .name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 220px;
      }
      .file-row .remove {
        cursor: pointer;
        text-decoration: underline;
      }
      .file-row .remove:hover {
        color: #eee;
        text-decoration-color: #eee;
      }

      /* Chip stile Figma: sempre con bg, niente bordo “duro” */
      .chipRow {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px !important;
        background: var(--chip) !important;
        border: none !important;
        border-radius: 999px !important;
        font-size: 12px;
        color: #eee;
        cursor: pointer;
        user-select: none;
        transition: background-color 120ms ease, transform 60ms ease,
          box-shadow 120ms ease;
      }
      .chip:hover {
        background: var(--chip-hover) !important;
      }

      .chip:active {
        background: var(--chip-active) !important;
        transform: translateY(0.5px);
      }
      .chip.active {
        background: var(--chip-active) !important;
      }
      .chip:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px var(--btn-hover) !important;
      }
      .chip.radio:not(.active) {
        background: var(--chip) !important;
        opacity: 1;
      }

      /* Badge (tag nel nodo) come chip del pannello, senza hover */
      .badge {
        display: inline-block;
        border: none !important;
        border-radius: 999px;
        padding: 4px 10px;
        margin: 2px 6px 0 0;
        font-size: 12px;
        background: var(--chip) !important;
        color: #eee;
      }

      /* Upload files button styled like toolbar buttons (no border) */
      #btnChoose.icon-btn {
        border: none !important;
        background: transparent !important;
        padding: 6px 8px;
        border-radius: 8px;
      }
      #btnChoose.icon-btn:hover {
        background: var(--btn-hover) !important;
      }
      #btnChoose.icon-btn:active {
        background: var(--btn-active) !important;
      }

      /* Status pulse resta, ma senza bordi lampeggianti altrove */
      #status.pulsing {
        animation: statusPulse 3s ease-in-out infinite;
      }
      @keyframes statusPulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
        100% {
          opacity: 1;
        }
      }

      /* Pan con space: cursore multidirezionale coerente */
      .space-pan #stage,
      .space-pan .node,
      .space-pan .handle {
        cursor: all-scroll !important;
      }
    </style>
    <style>
      /* UI: upload button senza gap icona-testo, e label selezione coerente */
      #btnChoose .material-symbols-outlined {
        margin-right: 0 !important;
      }
      #selInfo {
        font-size: 12px !important;
      }
      /* Mettere in fondo al SECONDO <style> */
      .descTitle {
        margin-top: 4px !important;
      }

      .descBlock .desc {
        margin-top: 4px !important;
      }
      /* --- Mettere in fondo al SECONDO <style> --- */
      /* Hover uniforme per Action/MainArea come Tags (vince su .chip.radio) */
      #actionChips .chip:hover,
      #mainAreaChips .chip:hover {
        background: var(--chip-hover, #1c1c1c) !important;
        border-color: #ffffff !important;
        color: #ffffff !important;
        opacity: 1 !important;
        cursor: pointer;
      }
      #actionChips .chip.active,
      #mainAreaChips .chip.active {
        background: var(--chip-active, #2f2f2f) !important;
        color: #fff !important;
      }

      /* Safari/Marquee: blocca selezione e drag anche su toolbar e sidebar */
      .marquee-active,
      .marquee-active *:not(input):not(textarea):not([contenteditable]) {
        -webkit-user-select: none !important;
        user-select: none !important;
      }
      .marquee-active header,
      .marquee-active header *,
      .marquee-active aside,
      .marquee-active aside * {
        -webkit-user-select: none !important;
        user-select: none !important;
      }
      .marquee-active img {
        -webkit-user-drag: none !important;
        user-drag: none !important;
      }
      /* In fondo al SECONDO <style>, per eliminare il doppio disegno degli edge:
         manteniamo SOLO il canvas per la resa visiva; lo SVG resta solo per l'hit. */
      .edge-visible {
        display: none !important;
      }

      /* === CSS (aggiungere in fondo al SECONDO <style>) ===================== */

      /* Help panel layout */
      #helpPanel {
        display: none;
        height: 100%;
        overflow-y: auto;
        padding: 10px;
        color: #eee;
        font-size: 13px;
        line-height: 1.5;
      }
      #helpPanel h2 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #fff;
        font-weight: 600;
      }
      #helpPanel .doc-section {
        border-top: 1px solid #333;
        padding: 8px 0;
      }
      #helpPanel .doc-section:first-of-type {
        border-top: none;
      }
      #helpPanel .doc-section h3 {
        margin: 0;
        font-size: 13px;
        color: #ccc;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      #helpPanel .doc-section h3 .material-symbols-outlined {
        font-size: 18px;
      }
      #helpPanel .doc-section h3::after {
        content: "expand_more";
        font-family: "Material Symbols Outlined";
        font-variation-settings: "FILL" 0, "wght" 200, "opsz" 24;
        font-size: 18px;
        opacity: 0.8;
        margin-left: auto;
      }
      #helpPanel .doc-section.open h3::after {
        content: "expand_less";
      }
      #helpPanel .doc-body {
        display: none;
        margin-top: 6px;
      }
      #helpPanel .doc-section.open .doc-body {
        display: block;
      }

      /* Icon bullet per liste nella doc */
      #helpPanel ul {
        margin: 6px 0 0 0;
        padding-left: 0;
        list-style: none;
      }
      #helpPanel li {
        margin: 4px 0;
        display: flex;
        gap: 6px;
        align-items: flex-start;
      }
      #helpPanel li .material-symbols-outlined {
        font-size: 16px;
        line-height: 1.2;
        opacity: 0.9;
      }

      /* Chip "type" solo per la prima lista di Node Structure */
      #helpPanel .chip.type {
        background: #222 !important;
        border: none !important;
        border-radius: 999px;
        padding: 2px 10px;
        color: #eee;
        font-size: 12px;
        display: inline-block;
        margin: 2px 4px 4px 0;
        pointer-events: none;
      }

      /* Nasconde sempre il vecchio titolo pannello proprietà */
      #panelTitle {
        display: none !important;
      }

      /* Help button stile “figma-like” (senza bordo) */
      #btnHelp.icon-btn {
        border: none !important;
        background: transparent !important;
        padding: 6px 8px;
        border-radius: 8px;
      }
      #btnHelp.icon-btn:hover {
        background: var(--btn-hover) !important;
      }
      #btnHelp.icon-btn:active {
        background: var(--btn-active) !important;
      }

      /* Overlay Help: full-screen, fuori da <aside> */
      #helpOverlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: rgba(14, 14, 14, 0.86);
        display: none;
        padding: 32px;
        overflow: auto;
        -webkit-user-select: text;
        user-select: text;
      }
      /* Pannello interno */
      #helpOverlay .doc-box {
        max-width: 920px;
        margin: 0 auto;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }
      /* Header pannello */
      #helpOverlay .doc-box-header {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        background: #1a1a1a;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      #helpOverlay .doc-title {
        font-weight: 600;
        font-size: 14px;
        margin-right: auto;
      }
      #helpOverlay .doc-box-body {
        padding: 16px;
      }
      /* Le sezioni doc esistenti si adattano dentro il box */
      #helpOverlay .doc-section {
        margin-bottom: 18px;
      }
      #helpOverlay .doc-section h3 {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 0 0 8px 0;
      }
      #helpOverlay .doc-section ul {
        margin: 8px 0 0 18px;
      }
      #helpOverlay .doc-section li {
        margin: 6px 0;
      }
      /* Bottoni stile toolbar, no bordo */
      #helpOverlay .icon-btn {
        appearance: none;
        border: none;
        background: transparent;
        color: #eee;
        padding: 6px 8px;
        border-radius: 8px;
        cursor: pointer;
      }
      #helpOverlay .icon-btn:hover {
        background: var(--btn-hover);
      }
      #helpOverlay .icon-btn:active {
        background: var(--btn-active);
      }
    </style>
    <style>
      :root {
        --bg: #0e0e0e;
        --panel: #151515;
        --ink: #ffffff;
        --muted: #bdbdbd;
        --line: #2a2a2a;
        --hover-light: #e6e6e6;
      }
      * {
        box-sizing: border-box;
      }
      /* Monochrome selection highlight */
      ::selection {
        background: rgba(255, 255, 255, 0.18);
        color: #fff;
      }
      ::-moz-selection {
        background: rgba(255, 255, 255, 0.18);
        color: #fff;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: #eee;
        font: 14px/1.4 system-ui;
        -webkit-tap-highlight-color: transparent;
      }
      header {
        padding: 8px;
        border-bottom: 1px solid #333;
        display: flex;
        gap: 10px;
        align-items: center;
        position: sticky;
        top: 0;
        z-index: 5;
        background: var(--bg);
      }
      button {
        background: #111;
        color: #eee;
        border: 1px solid #444;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
      }
      /* Hover feedback: bordo bianco puro; icona invariata */
      .icon-btn {
        border: 1px solid #444;
        transition: border-color 120ms ease, opacity 120ms ease;
      }
      .icon-btn:hover {
        opacity: 1;
        border-color: var(--hover-light);
      }
      .icon-btn:active {
        opacity: 0.9;
      }
      button:focus,
      button:focus-visible {
        outline: none;
        box-shadow: none;
      }
      /* Layout base */
      .app {
        display: grid;
        grid-template-columns: 1fr 380px;
        grid-template-rows: 50px 1fr;
        height: 100vh;
      }
      /* Sidebar nascosta: niente seconda colonna, canvas a tutta larghezza */
      .app.no-panel {
        grid-template-columns: 1fr !important;
      }
      .app.no-panel aside {
        display: none !important;
      }
      /* Header: copre tutte le colonne presenti (1 o 2) */
      .app header {
        grid-column: 1 / -1;
      }

      #stage {
        position: relative;
        overflow: hidden;
        user-select: none;
        background: #0e0e0e;
        background-image: linear-gradient(#111 1px, transparent 1px),
          linear-gradient(90deg, #111 1px, transparent 1px);
        background-size: 24px 24px, 24px 24px;
        background-position: 0 0, 0 0;
        cursor: default;
      }
      svg#edges {
        position: absolute;
        inset: 0;
        z-index: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .node {
        position: absolute;
        width: 320px;
        max-width: 400px;
        min-width: 260px;
        border: 1px solid #444;
        border-radius: 8px;
        background: var(--panel);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
        cursor: grab;
        z-index: 1;
        transform-origin: top left;
      }
      .node.dragging {
        cursor: grabbing;
      }
      .node.selected {
        outline: 2px solid #fff;
      }

      .body {
        padding: 8px;
      }
      .meta {
        color: var(--muted);
        font-size: 12px;
        font-family: inherit;
      }
      .divider {
        height: 1px;
        background: #2a2a2a;
        margin: 6px 0;
      }
      .kv {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 4px;
        font-size: 12px;
      }
      .kv div:nth-child(odd) {
        color: #bbb;
      }

      .tags {
        margin-top: 6px;
      }
      .badge {
        display: inline-block;
        border: 1px solid #444;
        border-radius: 999px;
        padding: 2px 6px;
        margin: 2px 6px 0 0;
        font-size: 12px;
      }

      .links {
        margin-top: 8px;
        font-size: 12px;
        font-family: inherit;
      }
      .links a {
        color: #fff;
        text-decoration: underline;
        display: inline-block;
        margin: 2px 10px 0 0;
      }

      .images {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .images img {
        display: block;
        width: 100%;
        height: auto;
        border: 1px solid #444;
        border-radius: 6px;
        pointer-events: none;
        -webkit-user-drag: none;
        user-drag: none;
      }
      .attachments {
        margin-top: 8px;
        font-size: 12px;
      }
      .attachments a {
        color: #fff;
        text-decoration: underline;
        margin-right: 10px;
      }

      /* Area cliccabile più grande, aspetto identico */
      .handle {
        position: absolute;
        width: 40px;
        height: 40px;
        pointer-events: auto;
      }
      /* cursori coerenti con le tue regole attuali */
      .handle.out {
        cursor: pointer;
      }
      .handle.in {
        cursor: grab;
      }
      .out {
        right: -22px;
        top: 50%;
        transform: translateY(-50%);
      }
      .in {
        left: -22px;
        top: 50%;
        transform: translateY(-50%);
      }
      /* Indicatori interni invariati (14x14), ma ricentrati nel 40px */
      .out::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        right: 13px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        border: 1px solid #000;
        border-radius: 50%;
      }
      .in::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        left: 13px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        border: 1px solid #000;
        clip-path: polygon(0% 0%, 100% 50%, 0% 100%);
      }

      .edge-visible {
        stroke: #ffffff; /* colore visivo */
        stroke-width: 2; /* spessore visivo */
        fill: none;
        cursor: pointer;
        pointer-events: stroke; /* path visibile cliccabile */
      }

      /* Canvas render: continuiamo a disegnare ma lasciamo il path cliccabile */
      .edge-visible.selected {
        stroke: #ffffff;
        stroke-width: 3;
      }
      .edge-visible.weak {
        stroke: #ffffff;
        stroke-opacity: 0.2;
        stroke-dasharray: 10 6;
        stroke-linecap: round;
        stroke-width: 1;
      }
      .edge-visible.weak.selected {
        stroke: #ffffff;
        stroke-opacity: 1;
        stroke-dasharray: 10 6;
        stroke-linecap: round;
        stroke-width: 2;
      }

      .marquee {
        position: absolute;
        border: 1px solid #bbb;
        background: rgba(255, 255, 255, 0.06);
        pointer-events: none;
        z-index: 2;
      }

      aside {
        background: #121212;
        border-left: 1px solid #333;
        padding: 10px;
        overflow: auto;
      }
      h3#panelTitle {
        margin: 0.6rem 0 0.3rem;
        font-size: 12px;
        font-weight: 400;
        text-transform: none;
        color: #bbb;
        letter-spacing: 0.02em;
      }
      label {
        display: block;
        font-size: 12px;
        margin-top: 12px;
      }
      input[type="text"],
      input[type="date"],
      textarea {
        width: 100%;
        background: #0d0d0d;
        border: 1px solid #444;
        border-radius: 6px;
        color: #eee;
        padding: 6px;
        font-family: inherit;
        margin-top: 6px;
      }
      /* unify focus ring and selection feel */
      input:focus,
      input:focus-visible,
      textarea:focus,
      textarea:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.18) inset;
        border-color: #555;
      }
      textarea {
        min-height: 140px;
        resize: vertical;
      }
      /* Date input: neutralize blue highlight/look */
      input[type="date"] {
        caret-color: #eee;
      }
      input[type="date"]::-webkit-datetime-edit-fields-wrapper {
        color: #eee;
      }
      input[type="date"]::-webkit-calendar-picker-indicator {
        filter: grayscale(100%);
        opacity: 0.9;
      }
      input[type="date"]::-moz-focus-inner {
        border: 0;
      }
      input[type="date"] {
        -moz-appearance: none;
      }
      .muted {
        color: #bbb;
      }

      .file-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 12px;
        padding: 6px 0;
        border-bottom: 1px solid #333;
      }
      .file-left {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }
      .thumb {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid #333;
        object-fit: cover;
        display: block;
      }
      .file-row .name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 220px;
      }
      .file-row .remove {
        cursor: pointer;
        text-decoration: underline;
      }
      .file-row .remove:hover {
        color: var(--hover-light);
        text-decoration-color: var(--hover-light);
      }

      .chipRow {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      /* Uniforma hover chip (tags, action, mainArea) */
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        border: 1px solid #444;
        border-radius: 999px;
        font-size: 12px;
        cursor: pointer;
        user-select: none;
        background: #0f0f0f;
        transition: background-color 0.2s;
      }
      .chip:hover {
        background-color: #444;
        color: #fff;
      }
      .chip.active {
        background: #1c1c1c;
        border-color: #666;
      }
      /* removed old CSS tooltip rules (data-tip) */
      .chip:hover {
        border-color: var(--hover-light);
      }
      .chip.radio:not(.active) {
        background: #0d0d0d;
        border-color: #3a3a3a;
        opacity: 0.85;
      }
      .chip.radio:hover {
        border-color: var(--hover-light);
      }

      /* Space-pan: cursore multidirezionale ovunque (stage, nodi, handle) */
      .space-pan #stage,
      .space-pan .node,
      .space-pan .handle {
        cursor: all-scroll !important;
      }

      /* Checkbox weak coerente con lo stile */
      #edgeForm .checkboxRow {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }
      #edgeForm input[type="checkbox"]#eDashed {
        appearance: none;
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border: 1px solid #444;
        border-radius: 3px;
        background: #000;
        display: inline-block;
        position: relative;
        vertical-align: middle;
      }
      #edgeForm input[type="checkbox"]#eDashed:focus {
        outline: none;
        box-shadow: none;
        border-color: #666;
      }
      #edgeForm input[type="checkbox"]#eDashed:checked::after {
        content: "";
        position: absolute;
        inset: 3px;
        background: #fff;
        border-radius: 1px;
      }
      /* Ensure radio chips (Action/Main area) get the same white hover border */
      .chip.radio:hover {
        border-color: #ffffff;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header style="grid-column: 1/3">
        <button id="btnNew" data-tip="New project">
          <span class="material-symbols-outlined">note_add</span>
        </button>
        <button id="btnOpen" data-tip="Open (Cmd/Ctrl+O)">
          <span class="material-symbols-outlined">file_open</span>
        </button>
        <button id="btnSave" data-tip="Save (Cmd/Ctrl+S)">
          <span class="material-symbols-outlined">file_save</span>
        </button>
        <button id="btnAdd" data-tip="New node (N)">
          <span class="material-symbols-outlined">add_box</span>
        </button>
        <button
          id="btnConnect"
          class="connect"
          data-tip="Connect nodes (Shift+C)"
        >
          <span class="material-symbols-outlined">conversion_path</span>
        </button>
        <button id="btnAuto" data-tip="Auto layout (Alt+A)">
          <span class="material-symbols-outlined">account_tree</span>
        </button>
        <button id="btnUndo" data-tip="Undo (Cmd/Ctrl+Z)">
          <span class="material-symbols-outlined">undo</span>
        </button>
        <button id="btnRedo" data-tip="Redo (Cmd/Ctrl+Shift+Z)">
          <span class="material-symbols-outlined">redo</span>
        </button>
        <button id="btnDel" data-tip="Delete (Del)">
          <span class="material-symbols-outlined">delete</span>
        </button>
        <button id="btnFit" data-tip="Fit view (0)">
          <span class="material-symbols-outlined">fullscreen</span>
        </button>
        <button id="btnHelp" class="icon-btn" data-tip="Help">
          <span class="material-symbols-outlined">help</span>
        </button>
        <span id="status" class="muted" style="margin-left: 8px"></span>
      </header>

      <div id="stage"><svg id="edges" preserveAspectRatio="none"></svg></div>

      <aside>
        <div id="nodeForm">
          <form onsubmit="return false;">
            <label>Date <input id="fDate" type="date" /></label>

            <label
              >Title
              <input id="fTitle" type="text" placeholder="" />
            </label>

            <label
              >Type
              <input
                id="fType"
                type="text"
                placeholder="Source · Concept · Sketch · Artefact · Feedback"
              />
              <div id="typeChips" class="chipRow"></div>
            </label>

            <label
              >Action
              <div id="actionChips" class="chipRow">
                <div class="chip radio" data-val="Exploring">Exploring</div>
                <div class="chip radio" data-val="Making">Making</div>
              </div>
            </label>

            <label
              >Main area
              <div id="mainAreaChips" class="chipRow">
                <div class="chip radio" data-val="Speculation">Speculation</div>
                <div class="chip radio" data-val="Interaction">Interaction</div>
                <div class="chip radio" data-val="Communication">
                  Communication
                </div>
              </div>
            </label>

            <label
              >Areas
              <input id="fAreas" type="text" placeholder="Comma separated" />
              <div id="areasChips" class="chipRow"></div>
            </label>

            <label
              >Description
              <textarea id="fDesc" placeholder=""></textarea>
            </label>

            <label
              >Tags
              <input id="fTags" type="text" placeholder="Comma separated" />
              <div id="tagsChips" class="chipRow"></div>
            </label>

            <label
              >Links
              <textarea id="fLinks" placeholder="One URL per line"></textarea>
            </label>

            <input id="fFiles" type="file" multiple style="display: none" />
            <div
              style="
                display: flex;
                gap: 8px;
                align-items: center;
                margin-top: 10px;
              "
            >
              <button
                id="btnChoose"
                type="button"
                title="Upload files"
                class="icon-btn"
              >
                <span
                  class="material-symbols-outlined"
                  style="margin-right: 6px"
                  >upload</span
                >
                Upload files
              </button>
              <span id="selInfo" class="muted">No selection</span>
            </div>
            <div id="filesList" class="muted" style="margin-top: 6px"></div>
          </form>
        </div>

        <div id="edgeForm" style="display: none">
          <div class="muted" style="font-size: 12px; margin-bottom: 6px">
            From: <span id="eFrom">—</span> → To: <span id="eTo">—</span>
          </div>
          <label class="checkboxRow"
            ><input id="eDashed" type="checkbox" /> Weak (dashed)</label
          >
        </div>

        <input
          id="openFile"
          type="file"
          accept="application/json"
          style="display: none"
        />

        <!-- HTML: aggiungi il pannello help in fondo a <aside>, dopo i form -->
        <div id="helpPanel">
          <h2>Threadscape — Documentation</h2>

          <div class="doc-section open">
            <h3>
              <span class="material-symbols-outlined">lightbulb</span> Concept
              and Purpose
            </h3>
            <div class="doc-body">
              <p>
                Threadscape is a tool to map and reflect on design processes. It
                is designed to capture the often nonlinear flow of ideas and
                materials that emerge while working on a project.
              </p>
              <p>
                Each node represents a design atom — not simply a chronological
                step, but any meaningful element that shapes the project: a
                concept, an artefact, a reference, an insight, and more. The map
                shows how these elements branch and merge, making visible the
                structure and logic of the process.
              </p>
              <ul>
                <li>
                  <span class="material-symbols-outlined">flowchart</span>
                  <strong>During a project:</strong><br />to clarify what is
                  happening, explore alternatives, and make sense of complex
                  progressions.
                </li>
                <li>
                  <span class="material-symbols-outlined">door_open</span>
                  <strong>After a project:</strong><br />to analyse its
                  structure, conduct research on design processes, and
                  communicate the underlying decisions and sources.
                </li>
              </ul>
              <p>
                It promotes open documentation and shared understanding of
                design work. All data is stored locally and can be freely
                modified or shared.
              </p>
            </div>
          </div>

          <div class="doc-section">
            <h3>
              <span class="material-symbols-outlined">schema</span> Node
              Structure
            </h3>
            <div class="doc-body">
              <p>
                Un nodo può rappresentare: <span class="chip key">Brief</span>,
                <span class="chip key">Source</span>,
                <span class="chip key">Collection</span>,
                <span class="chip key">Concept</span>,
                <span class="chip key">Sketch</span>,
                <span class="chip key">Artefact</span>,
                <span class="chip key">Observation</span>,
                <span class="chip key">Feedback</span>,
                <span class="chip key">Decision</span>,
                <span class="chip key">Output</span>.
              </p>
              <p><strong>Campi (tutti opzionali):</strong></p>
              <ul>
                <li>
                  <span class="chip key">Title</span> — nome dell’elemento
                </li>
                <li>
                  <span class="chip key">Date</span> — data chiave (precompilata
                  ma editabile)
                </li>
                <li>
                  <span class="chip key">Type</span> — categoria (es. Concept,
                  Artefact…)
                </li>
                <li>
                  <span class="chip key">Action</span> — atteggiamento (es.
                  Exploring / Making)
                </li>
                <li>
                  <span class="chip key">Main Area</span> — dominio primario
                  (es. Speculation)
                </li>
                <li>
                  <span class="chip key">Areas</span> — parole chiave secondarie
                </li>
                <li>
                  <span class="chip key">Tags</span> — parole chiave libere per
                  filtri
                </li>
                <li>
                  <span class="chip key">Description</span> — testo (200–1000
                  caratteri)
                </li>
                <li><span class="chip key">Links</span> — un link per riga</li>
                <li>
                  <span class="chip key">Files</span> — immagini/PDF (compressi
                  in <code>assets/</code>)
                </li>
              </ul>
              <p>
                <strong>Main Area vs Areas</strong><br />
                <span class="chip key">Main Area</span> è un’etichetta unica per
                il dominio primario.<br />
                <span class="chip key">Areas</span> sono keyword multiple
                (temi/contesti secondari).
              </p>
              <p>
                Il pannello suggerisce <span class="chip key">Type</span>,
                <span class="chip key">Areas</span> e
                <span class="chip key">Tags</span> già usati.
              </p>
            </div>
          </div>

          <div class="doc-section">
            <h3>
              <span class="material-symbols-outlined">fork_right</span>
              Connections and Interaction
            </h3>
            <div class="doc-body">
              <p>Le connessioni mostrano le relazioni tra nodi:</p>
              <ul>
                <li>
                  <span class="chip key">Dirette</span> — linea piena (relazione
                  forte/esplicita)
                </li>
                <li>
                  <span class="chip key">Weak</span> — linea tratteggiata
                  (relazione indiretta/ipotetica)
                </li>
              </ul>
              <p><strong>Interazioni base:</strong></p>
              <ul>
                <li>
                  Pan: <span class="chip kbd">Space</span> + trascina / trackpad
                </li>
                <li>Zoom: rotella/trackpad</li>
                <li>Selezione multipla: trascina per creare un rettangolo</li>
                <li>Muovi nodi: trascina i nodi selezionati</li>
                <li>
                  Crea connessione: trascina da
                  <span class="badge io out">OUT</span> a
                  <span class="badge io in">IN</span>
                </li>
                <li>
                  <span class="chip key">Alt/⌥</span> trascina nodi → duplica
                  &amp; sposta
                </li>
              </ul>
            </div>
          </div>

          <div class="doc-section">
            <h3>
              <span class="material-symbols-outlined">conversion_path</span>
              Connect Tool
            </h3>
            <div class="doc-body">
              <ol>
                <li>Seleziona una o più sorgenti</li>
                <li>
                  Clicca
                  <span
                    class="material-symbols-outlined"
                    style="vertical-align: middle"
                    >conversion_path</span
                  >
                  <span class="chip key">Connect</span>
                </li>
                <li>Clicca i target da connettere</li>
                <li>
                  Riclicca <span class="chip key">Connect</span> per confermare
                </li>
              </ol>
              <p>
                <span class="chip kbd">C</span> con esattamente 2 nodi
                selezionati collega direttamente da sinistra a destra.
              </p>
            </div>
          </div>

          <div class="doc-section">
            <h3>
              <span class="material-symbols-outlined">save</span> Saving and
              Opening Projects
            </h3>
            <div class="doc-body">
              <ul>
                <li>
                  Salvataggio crea: <code>project.json</code> + cartella
                  <code>assets/</code>
                </li>
                <li>
                  Le immagini nuove vengono convertite in
                  <span class="chip key">JPEG</span>, lato lungo max
                  <span class="chip key">1500px</span>, compresse
                  automaticamente
                </li>
                <li>
                  Per aprire: seleziona la cartella del progetto (carica
                  <code>project.json</code>)
                </li>
                <li>Disponibile export leggero JSON (senza file)</li>
              </ul>
            </div>
          </div>

          <div class="doc-section">
            <h3>
              <span class="material-symbols-outlined">keyboard</span> Toolbar &
              Shortcuts
            </h3>
            <div class="doc-body">
              <ul>
                <li>
                  <span class="chip key">New Project</span> —
                  <span class="chip kbd">⌘/Ctrl + N</span>
                </li>
                <li>
                  <span class="chip key">Open Project</span> —
                  <span class="chip kbd">⌘/Ctrl + O</span>
                </li>
                <li>
                  <span class="chip key">Save Project</span> —
                  <span class="chip kbd">⌘/Ctrl + S</span>
                </li>
                <li>
                  <span class="chip key">New Node</span> —
                  <span class="chip kbd">N</span>
                </li>
                <li>
                  <span class="chip key">Direct Connect</span> (2 selezionati) —
                  <span class="chip kbd">C</span>
                </li>
                <li>
                  <span class="chip key">Auto Layout</span> —
                  <span class="chip kbd">⇧ + A</span>
                </li>
                <li>
                  <span class="chip key">Undo</span> —
                  <span class="chip kbd">⌘/Ctrl + Z</span>
                </li>
                <li>
                  <span class="chip key">Redo</span> —
                  <span class="chip kbd">⌘/Ctrl + ⇧ + Z</span>
                </li>
                <li>
                  <span class="chip key">Fit View</span> —
                  <span class="chip kbd">0</span>
                </li>
                <li>
                  <span class="chip key">Upload Files</span> (nodo selezionato)
                  — <span class="chip kbd">U</span>
                </li>
                <li>
                  <span class="chip key">Group</span> —
                  <span class="chip kbd">⌘/Ctrl + G</span>
                </li>
                <li>
                  <span class="chip key">Ungroup</span> —
                  <span class="chip kbd">⌘/Ctrl + ⇧ + G</span>
                </li>
              </ul>
              <p>
                <strong>Selezione rapida:</strong>
                <span class="chip key">⇧ + click</span> su nodi/edge per
                multiselezione. <span class="chip key">⌥ + click</span> su edge
                per inserire un nodo intermedio.
              </p>
            </div>
          </div>
        </div>
      </aside>
    </div>

    <script>
      (() => {
        const GRID = 24,
          NODE_W = 320,
          NODE_H = 180,
          HGAP = 160,
          VGAP = 40,
          MIN_LAYER_GAP = 24;

        // JS: toggle pannello help + accordion (aggiungere nel blocco script principale)
        const btnHelp = document.getElementById("btnHelp");
        const helpPanel = document.getElementById("helpPanel");

        // Build Help content (English, icon bullets, no separate Connect section)
        if (helpPanel) {
          helpPanel.innerHTML = `
          <h2>Threadscape — Documentation</h2>
          <div class="doc-section open">
            <h3><span class="material-symbols-outlined">lightbulb</span> Concept and Purpose</h3>
            <div class="doc-body">
              <ul>
                <li><span class="material-symbols-outlined">info</span>
                  <span>Threadscape is a tool to map and reflect on design processes. It is designed to capture the often nonlinear flow of ideas and materials that emerge while working on a project.</span>
                </li>
                <li><span class="material-symbols-outlined">account_tree</span>
                  <span>Each node represents a design atom — not simply a chronological step, but any meaningful element that shapes the project: a concept, an artefact, a reference, an insight, and more. The map shows how these elements branch and merge, making visible the structure and logic of the process.</span>
                </li>
                <li><span class="material-symbols-outlined">schedule</span>
                  <span><strong>During a project</strong>, to clarify what is happening, explore alternatives, and make sense of complex progressions.</span>
                </li>
                <li><span class="material-symbols-outlined">history_edu</span>
                  <span><strong>After a project</strong>, to analyse its structure, conduct research on design processes, and communicate the underlying decisions and sources.</span>
                </li>
                <li><span class="material-symbols-outlined">lock_open_right</span>
                  <span>It promotes open documentation and shared understanding of design work. All data is stored locally and can be freely modified or shared.</span>
                </li>
              </ul>
            </div>
          </div>

          <div class="doc-section">
            <h3><span class="material-symbols-outlined">schema</span> Node Structure</h3>
            <div class="doc-body">
              <p>Each node can represent any meaningful element of a design process, such as:</p>
              <ul>
                <li><span class="chip type">Brief</span><br>the initial framing of the project, the question or design challenge that triggers it (project goal, starting hypothesis, constraint)</li>
                <li><span class="chip type">Source</span><br>external material used as input and inspiration (case study, reference, article, artwork, dataset, book, website)</li>
                <li><span class="chip type">Finding</span><br>evidence or discovery that emerges from research or inquiry, providing new knowledge about the context, users, or problem (interview insight, collected data, observed pattern)</li>
                <li><span class="chip type">Collection</span><br>curated group of references organised around a theme, showing a first layer of interpretation (moodboard, image set, text set)</li>
                <li><span class="chip type">Concept</span><br>the core idea or proposition that drives exploration</li>
                <li><span class="chip type">Sketch</span><br>embryonic design attempt, rough and provisional, not yet fully articulated (drawing, wireframe, doodle, draft)</li>
                <li><span class="chip type">Artefact</span><br>tangible outcome produced during the process, with a degree of autonomy or completeness (prototype, installation, poster, website, editorial, app, gadget)</li>
                <li><span class="chip type">Observation</span><br>reflection, analysis, and learning from the process, including when things don’t work (note, failure, discovery, insight)</li>
                <li><span class="chip type">Feedback</span><br>external response and evaluation from others (peer comment, critique, review)</li>
                <li><span class="chip type">Decision</span><br>moment where something is defined or chosen, shaping the direction (design choice, milestone, strategic shift)</li>
                <li><span class="chip type">Output</span><br>the final, consolidated result</li>
              </ul>

              <h4 style="margin-top:18px; color:#bbb; font-size:12px; font-weight:600;">Node fields</h4>
              <p>These fields describe the content of each node (all optional):</p>

              <ul>
                <li><strong>Title</strong><br>name of the element, summarising the node content</li>
                <li><strong>Date</strong><br>key date for the element (automatically set to the current date but editable and backdatable)</li>
                <li><strong>Type</strong><br>choose or write a category (e.g. Concept, Artefact, Feedback...)</li>
                <li><strong>Action</strong><br>the attitude involved, e.g. Exploring or Making</li>
                <li><strong>Main Area</strong><br>the main disciplinary area (select only if it includes the node)</li>
                <li><strong>Areas</strong><br>specific areas explored (comma-separated keywords)</li>
                <li><strong>Tags</strong><br>free keywords for filtering; useful for recurring typologies, transversal, thematic, structural or methodological elements</li>
                <li><strong>Description</strong><br>explanatory text (200–1000 characters including spaces)</li>
                <li><strong>Links</strong><br>one link per line</li>
                <li><strong>Files</strong><br>upload images or PDFs (they are stored and compressed automatically in the assets folder)</li>
              </ul>

              <ul style="margin-top:10px;">
                <li><strong>Main Area</strong> is a single label defining the primary domain (e.g., “Speculation”).</li>
                <li><strong>Areas</strong> are multiple free-form keywords describing secondary themes or contexts (e.g., “biology, interaction design, performance”).</li>
                <li><strong>Suggestions</strong> reuse previously used Types, Areas, and Tags to speed up data entry.</li>
              </ul>
            </div>
          </div>

          <div class="doc-section">
            <h3><span class="material-symbols-outlined">gesture_select</span> Interaction</h3>
            <div class="doc-body">
              <ul>
                <li><span class="material-symbols-outlined">pan_tool</span><strong>Pan the canvas:</strong><br>trackpad or hold Space and drag</li>
                <li><span class="material-symbols-outlined">zoom_in</span><strong>Zoom:</strong><br>trackpad or mouse wheel</li>
                <li><span class="material-symbols-outlined">select_all</span><strong>Select multiple nodes:</strong><br>drag to create a selection rectangle</li>
                <li><span class="material-symbols-outlined">open_with</span><strong>Move nodes:</strong><br>drag them (groups move together)</li>
                <li><span class="material-symbols-outlined">automation</span><strong>Create a connection:</strong><br>drag from ● IN to ► OUT</li>
                <li><span class="material-symbols-outlined">graph_1</span><strong>Click a ● IN handle:</strong><br>creates a connected duplicate node (inheriting Action and Main Area)</li>
                <li><span class="material-symbols-outlined">conversion_path</span><strong>Connect mode:</strong><br>select one or more sources, click on the toolbar, click one or more targets, click again to exit</li>
                <li><span class="material-symbols-outlined">diagonal_line</span><strong>Direct connect:</strong><br>with exactly two nodes selected, press C to connect left → right</li>
                <li><span class="material-symbols-outlined">commit</span><strong>Alt/Option + click edge:</strong><br>split an edge and insert a node in the middle</li>
                <li><span class="material-symbols-outlined">power_input</span><strong>Weak connections:</strong><br>click an edge and enable “Weak”</li>
              </ul>
            </div>
          </div>

          <div class="doc-section">
            <h3><span class="material-symbols-outlined">save</span> Saving and Opening Projects</h3>
            <div class="doc-body">
              <ul>
                <li><span class="material-symbols-outlined">folder</span><span><strong>Saving</strong> creates a folder with:</span></li>
                <li style="margin-left:22px;"><span class="material-symbols-outlined">description</span><span><code>project.json</code> — nodes, connections, positions, text</span></li>
                <li style="margin-left:22px;"><span class="material-symbols-outlined">folder_copy</span><span><code>assets/</code> — attached files</span></li>
                <li><span class="material-symbols-outlined">image</span><span>New images are converted to <strong>JPEG</strong>, resized to a max of <strong>1500px</strong> (longest side), and compressed.</span></li>
                <li><span class="material-symbols-outlined">download_done</span><span>No need to place files manually into <code>assets</code>.</span></li>
                <li><span class="material-symbols-outlined">folder_open</span><span><strong>Open</strong>: select the project folder — Threadscape loads <code>project.json</code>.</span></li>
                <li><span class="material-symbols-outlined">data_object</span><span>Lightweight JSON export (without files) is available for quick sharing.</span></li>
              </ul>
            </div>
          </div>

          <div class="doc-section">
            <h3><span class="material-symbols-outlined">keyboard</span> Toolbar and Shortcuts</h3>
            <div class="doc-body">
              <ul>
                <li><span class="material-symbols-outlined">note_add</span><span>New Project — ⌘/Ctrl + N</span></li>
                <li><span class="material-symbols-outlined">file_open</span><span>Open Project — ⌘/Ctrl + O</span></li>
                <li><span class="material-symbols-outlined">file_save</span><span>Save Project — ⌘/Ctrl + S</span></li>
                <li><span class="material-symbols-outlined">add_box</span><span>New Node — N</span></li>
                <li><span class="material-symbols-outlined">bolt</span><span>Direct Connect (2 selected) — C</span></li>
                <li><span class="material-symbols-outlined">account_tree</span><span>Auto Layout — ⇧ + A</span></li>
                <li><span class="material-symbols-outlined">undo</span><span>Undo — ⌘/Ctrl + Z</span></li>
                <li><span class="material-symbols-outlined">redo</span><span>Redo — ⌘/Ctrl + ⇧ + Z</span></li>
                <li><span class="material-symbols-outlined">fullscreen</span><span>Fit View — 0</span></li>
                <li><span class="material-symbols-outlined">upload</span><span>Upload Files (selected node) — U</span></li>
                <li><span class="material-symbols-outlined">group</span><span>Group — ⌘/Ctrl + G</span></li>
                <li><span class="material-symbols-outlined">group_off</span><span>Ungroup — ⌘/Ctrl + ⇧ + G</span></li>
              </ul>
              <ul>
                <li><span class="material-symbols-outlined">select_check_box</span><span>⇧ + click edges — multi-select edges</span></li>
                <li><span class="material-symbols-outlined">select_check_box</span><span>⇧ + click nodes — multi-select nodes</span></li>
                <li><span class="material-symbols-outlined">call_split</span><span>⌥ + click edge — split an edge and insert a node in the middle</span></li>
              </ul>
            </div>
          </div>
          `;
        }
        btnHelp?.addEventListener("click", () => {
          const show = helpPanel?.style.display !== "block";
          if (helpPanel) helpPanel.style.display = show ? "block" : "none";
          // nascondi i form quando il help è aperto
          const nf = document.getElementById("nodeForm");
          const ef = document.getElementById("edgeForm");
          if (nf) nf.style.display = show ? "none" : "";
          if (ef) ef.style.display = "none";
        });

        // accordion
        helpPanel?.querySelectorAll(".doc-section h3").forEach((h) => {
          h.addEventListener("click", () => {
            h.parentElement.classList.toggle("open");
          });
        });
        const IMG_MAX_SIDE = 1500,
          IMG_TARGET_BYTES = 500 * 1024;
        const CLICK_THRESHOLD = 10;

        const projectCtx = { mode: null, dirHandle: null };

        const history = {
          undo: [],
          redo: [],

          limit: 80,
          lock: false,
          debounce: null,
        };
        const snap = () => ({
          nodes: structuredClone(state.nodes),
          edges: structuredClone(state.edges),
          selNodes: [...state.selNodes],
          selEdges: [...state.selEdges],
          pan: { ...state.pan },
          zoom: state.zoom,
        });
        function pushHistory() {
          if (history.lock) return;
          history.undo.push(snap());
          if (history.undo.length > history.limit) history.undo.shift();
          history.redo.length = 0;
        }
        const scheduleHistory = () => {
          clearTimeout(history.debounce);
          history.debounce = setTimeout(pushHistory, 400);
        };

        const state = {
          nodes: [],
          edges: [],
          selNodes: new Set(),
          selEdges: new Set(),
          zoom: 1,
          pan: { x: 0, y: 0 },
          press: null,
          dragLink: null,
          spaceDown: false,
          marquee: null,
          ignoreNextStageClick: false,
          clip: null,
          groupSeq: 1,
        };

        function $(s) {
          return document.querySelector(s);
        }
        const stage = $("#stage"),
          edgesSVG = $("#edges"),
          status = $("#status");
        let __statusTimer = null;
        function setStatus(msg) {
          status.textContent = msg || "";
          clearTimeout(__statusTimer);
          if (!msg) return;
          if (status.classList.contains("pulsing")) return; // non auto-hide durante connect mode
          __statusTimer = setTimeout(() => {
            status.textContent = "";
          }, 3000);
        }

        /* ==== CONNECT FSM — self-contained in this IIFE ==== */
        // Mini helpers for status with HTML/pulse
        const setStatusHTML = (html) => {
          status.innerHTML = html || "";
        };
        const setStatusPulseHTML = (html, on = false) => {
          setStatusHTML(html);
          status.classList.toggle("pulsing", !!on);
        };
        const btnConnect = document.getElementById("btnConnect");
        // Private state
        let connectMode = false;
        let connectSources = [];
        const MSG = {
          needSources: `Select source node(s), then press <span class="material-symbols-outlined status-ico">conversion_path</span>Connect.`,
          selectTargets: `Select target node(s)...`,
          completeHint: `Complete by clicking <span class="material-symbols-outlined status-ico">conversion_path</span>.`,
          multiRule: `Multiple sources can connect to a single target only.`,
          cancelled: `Operation cancelled.`,
          created: (n) => `Created ${n} connection${n === 1 ? "" : "s"}.`,
        };
        const enterConnectMode = () => {
          connectMode = true;
          btnConnect?.classList.add("active");
          if (state.selNodes.size === 0) {
            connectSources = [];
            setStatusPulseHTML(MSG.needSources, true);
          } else {
            connectSources = [...state.selNodes];
            setStatusPulseHTML(MSG.selectTargets, true);
          }
        };
        const exitConnectMode = (finalMsgHTML = "") => {
          connectMode = false;
          connectSources = [];
          btnConnect?.classList.remove("active");
          setStatusPulseHTML(finalMsgHTML, false);
        };
        const updateConnectStatusDuringSelection = () => {
          if (!connectMode) return;
          if (connectSources.length === 0) {
            setStatusPulseHTML(MSG.needSources, true);
            return;
          }
          const targets = [...state.selNodes].filter(
            (id) => !connectSources.includes(id)
          );
          setStatusPulseHTML(
            targets.length > 0 ? MSG.completeHint : MSG.selectTargets,
            true
          );
        };
        // Bindings
        btnConnect?.addEventListener("click", () => {
          if (!connectMode) {
            enterConnectMode();
            return;
          }
          const sources = [...connectSources];
          const targets = [...state.selNodes].filter(
            (id) => !connectSources.includes(id)
          );
          if (sources.length === 0) {
            setStatusPulseHTML(MSG.needSources, true);
            return;
          }
          if (sources.length > 1 && targets.length > 1) {
            setStatusPulseHTML(MSG.multiRule, true);
            return;
          }
          let created = 0;
          pushHistory();
          for (const s of sources) {
            for (const t of targets) {
              if (s !== t && !state.edges.some((e) => e.s === s && e.t === t)) {
                addEdge(s, t);
                created++;
              }
            }
          }
          renderEdges();
          exitConnectMode(created > 0 ? MSG.created(created) : "");
        });
        document.addEventListener("keydown", (e) => {
          const tag = document.activeElement?.tagName;
          const inText =
            tag === "INPUT" ||
            tag === "TEXTAREA" ||
            document.activeElement?.isContentEditable;
          if (inText) return;
          // Shift + C → comporta come pressione del pulsante Connect
          if (e.key.toLowerCase() === "c" && e.shiftKey) {
            e.preventDefault();
            btnConnect?.click();
            return;
          }
          // C semplice → collega esattamente 2 nodi selezionati (senza toccare il pulsante)
          if (
            e.key.toLowerCase() === "c" &&
            !e.shiftKey &&
            !e.metaKey &&
            !e.ctrlKey &&
            !e.altKey
          ) {
            e.preventDefault();
            const ids = [...state.selNodes];
            if (ids.length === 2) {
              const a = getNodeById(ids[0]);
              const b = getNodeById(ids[1]);
              if (a && b && a.id !== b.id) {
                // Direzione: sinistra → destra; se X uguali, alto → basso
                let s = a.id,
                  t = b.id;
                if (a.x > b.x || (a.x === b.x && a.y > b.y)) {
                  s = b.id;
                  t = a.id;
                }
                if (!state.edges.some((e) => e.s === s && e.t === t)) {
                  pushHistory();
                  addEdge(s, t);
                  renderEdges();
                  setStatus("Created 1 connection.");
                }
              }
            }
            return;
          }
          if (e.key === "Escape" && connectMode) {
            e.preventDefault();
            exitConnectMode(MSG.cancelled);
            return;
          }
        });
        document.addEventListener(
          "click",
          () => {
            if (!connectMode) return;
            setTimeout(updateConnectStatusDuringSelection, 0);
          },
          false
        );

        // === EDGE CANVAS (disegno) + SCHEDULER ===
        const edgeCanvas = document.createElement("canvas");
        edgeCanvas.id = "edgesCanvas";
        edgeCanvas.style.position = "absolute";
        edgeCanvas.style.inset = "0";
        edgeCanvas.style.zIndex = "1"; // sotto ai nodi (.node ha z-index:1, ma trasformata; questo resta dietro)
        edgeCanvas.style.pointerEvents = "none"; // eventi restano all'SVG per hit-test
        stage.insertBefore(edgeCanvas, edgesSVG.nextSibling);
        const edgeCtx = edgeCanvas.getContext("2d", { alpha: true });

        let __edgesCSSHidden = false;
        function __hideSvgVisibleOnce() {
          if (__edgesCSSHidden) return;
          __edgesCSSHidden = true;
          // Se non hai messo la regola CSS, nascondi via JS
          edgesSVG
            .querySelectorAll(".edge-visible")
            .forEach((p) => (p.style.display = "none"));
        }

        function resizeEdgeCanvasToStage() {
          const r = stage.getBoundingClientRect();
          // pixel reali per nitidezza su HiDPI
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          edgeCanvas.width = Math.max(1, Math.round(r.width * dpr));
          edgeCanvas.height = Math.max(1, Math.round(r.height * dpr));
          edgeCanvas.style.width = `${Math.max(1, Math.round(r.width))}px`;
          edgeCanvas.style.height = `${Math.max(1, Math.round(r.height))}px`;
          edgeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function worldTransform(ctx) {
          // Trasforma world->screen come fai per SVG (pan/zoom)
          ctx.translate(state.pan.x, state.pan.y);
          ctx.scale(state.zoom, state.zoom);
        }

        function drawAllEdgesOnCanvas() {
          __hideSvgVisibleOnce();
          resizeEdgeCanvasToStage();
          const ctx = edgeCtx;
          ctx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);

          // 1) edge normali
          ctx.save();
          worldTransform(ctx);
          for (let i = 0; i < state.edges.length; i++) {
            const e = state.edges[i];
            const s = anchor(e.s, "right");
            const t = anchor(e.t, "left");
            if (!s || !t) continue;

            const isWeak = !!e.dashed;
            const isSel = state.selEdges.has(i);

            // Impostazioni comuni
            ctx.lineCap = "butt"; // cap rettangolare per coerenza

            if (isWeak) {
              // WEAK: più fini, grigio scuro, gap breve
              const dash = [8, 3]; // gap più corto
              ctx.setLineDash(dash);

              if (isSel) {
                // WEAK selezionati: più spessi e bianchi (restano tratteggiati)
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#eeeeee";
              } else {
                ctx.lineWidth = 2; // più fini
                ctx.strokeStyle = "#444444"; // grigio scu
              }
            } else {
              // NORMAL
              ctx.setLineDash([]);
              if (isSel) {
                // Selezionati: più spessi e bianchi
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#ffffff";
              } else {
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#9a9a9a";
              }
            }

            drawCubic(ctx, s, t);
          }

          // 2) ghost durante drag edge (disegno “provvisorio” sul canvas)
          if (state.dragLink && state.dragLink.active) {
            const to = { x: state.dragLink.x, y: state.dragLink.y };
            ctx.setLineDash([]);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffffff";
            for (const sid of state.dragLink.sources || []) {
              const a =
                state.dragLink.from === "out"
                  ? anchor(sid, "right")
                  : anchor(sid, "left");
              const A = state.dragLink.from === "out" ? a : to;
              const B = state.dragLink.from === "out" ? to : a;
              drawCubic(ctx, A, B);
            }
          }
          ctx.restore();
        }

        function drawCubic(ctx, a, b) {
          const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.bezierCurveTo(a.x + dx, a.y, b.x - dx, b.y, b.x, b.y);
          ctx.stroke();
        }

        let __edgeRAF = null;
        function scheduleEdgeCanvasDraw() {
          if (__edgeRAF) return;
          __edgeRAF = requestAnimationFrame(() => {
            __edgeRAF = null;
            drawAllEdgesOnCanvas();
          });
        }

        // === UX: hit-test del vuoto & flag gesto ===
        function isBlankAtPoint(clientX, clientY) {
          const el = document.elementFromPoint(clientX, clientY);
          return el === stage || el === edgesSVG;
        }
        // mousedown nato sul vuoto?
        let bgPointerDown = false;
        // durante questo gesto si è mosso (pan o marquee)?
        let gestureMoved = false;

        const f = {
          date: $("#fDate"),
          title: $("#fTitle"),
          type: $("#fType"),
          actionChips: $("#actionChips"),
          mainAreaChips: $("#mainAreaChips"),
          areas: $("#fAreas"),
          areasChips: $("#areasChips"),
          tags: $("#fTags"),
          tagsChips: $("#tagsChips"),
          desc: $("#fDesc"),
          links: $("#fLinks"),
          files: $("#fFiles"),
          filesList: $("#filesList"),
          selInfo: $("#selInfo"),
          btnChoose: $("#btnChoose"),
          openFile: $("#openFile"),
          nodeForm: $("#nodeForm"),
          edgeForm: $("#edgeForm"),
          eFrom: $("#eFrom"),
          eTo: $("#eTo"),
          eDashed: $("#eDashed"),
          panelTitle: $("#panelTitle"),
          typeChips: $("#typeChips"),
        };

        const uid = () => "n" + Math.random().toString(36).slice(2, 9);
        function fmtTime10() {
          const d = new Date();
          const hh = String(d.getHours()).padStart(2, "0");
          const mm = String(d.getMinutes()).padStart(2, "0");
          const ss = String(d.getSeconds()).padStart(2, "0");
          const tenth = Math.floor(d.getMilliseconds() / 100);
          return `${hh}:${mm}:${ss}`;
        }
        const esc = (s) =>
          (s ?? "").replace(
            /[&<>"']/g,
            (c) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              }[c])
          );

        function splitListComma(str) {
          return (str || "")
            .split(/,\s*/)
            .map((s) => s.trim())
            .filter(Boolean);
        }
        function normalizeToken(s) {
          if (!s) return "";
          const t = s.trim().replace(/\s+/g, " ");
          if (!t) return "";
          return t.charAt(0).toUpperCase() + t.slice(1).toLowerCase();
        }
        function normalizeArray(arr) {
          const seen = new Set(),
            out = [];
          for (const raw of arr) {
            const n = normalizeToken(raw);
            if (!n) continue;
            const key = n.toLowerCase();
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(n);
          }
          return out;
        }
        function normalizeURL(s) {
          if (!s) return null;
          let u = s.trim();
          if (!/^https?:\/\//i.test(u)) u = "https://" + u;
          try {
            new URL(u);
            return u;
          } catch {
            return null;
          }
        }
        function bytes(b) {
          if (!Number.isFinite(b)) return "";
          const k = 1024,
            u = ["B", "KB", "MB", "GB"];
          let i = 0;
          while (b >= k && i < u.length - 1) {
            b /= k;
            i++;
          }
          return b.toFixed(b < 10 && i > 0 ? 1 : 0) + " " + u[i];
        }
        function todayYMD() {
          const d = new Date();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${d.getFullYear()}-${mm}-${dd}`;
        }
        function formatDateIT(ymd) {
          if (!ymd) return "";
          const [y, m, d] = ymd.split("-");
          return y && m && d ? `${d}/${m}/${y}` : ymd;
        }

        function toWorld(cx, cy) {
          const r = stage.getBoundingClientRect();
          return {
            x: (cx - r.left - state.pan.x) / state.zoom,
            y: (cy - r.top - state.pan.y) / state.zoom,
          };
        }
        function fromWorld(x, y) {
          return {
            x: x * state.zoom + state.pan.x,
            y: y * state.zoom + state.pan.y,
          };
        }

        function ensureSVGSize() {
          const r = stage.getBoundingClientRect();
          const w = Math.max(1, Math.round(r.width)),
            h = Math.max(1, Math.round(r.height));
          edgesSVG.setAttribute("width", w);
          edgesSVG.setAttribute("height", h);
          edgesSVG.setAttribute(
            "viewBox",
            `${-state.pan.x / state.zoom} ${-state.pan.y / state.zoom} ${
              w / state.zoom
            } ${h / state.zoom}`
          );
        }
        window.addEventListener("resize", () => {
          ensureSVGSize();
          updateGrid();
        });

        // Canvas segue lo stage
        window.addEventListener("resize", () => {
          resizeEdgeCanvasToStage();
          scheduleEdgeCanvasDraw();
        });
        ensureSVGSize();
        function updateGrid() {
          const sizeX = GRID * state.zoom,
            sizeY = GRID * state.zoom;
          const posX = state.pan.x % sizeX,
            posY = state.pan.y % sizeY;
          stage.style.backgroundSize = `${sizeX}px ${sizeY}px, ${sizeX}px ${sizeY}px`;
          stage.style.backgroundPosition = `${posX}px ${posY}px, ${posX}px ${posY}px`;
        }

        function emptyData() {
          return {
            date: todayYMD(),
            title: "",
            type: "",
            action: null,
            mainArea: null,
            areas: [],
            tags: [],
            desc: "",
            links: [],
            files: [],
          };
        }
        function getNodeById(id) {
          return state.nodes.find((n) => n.id === id) || null;
        }
        function getEdgeByIndex(i) {
          return state.edges[i] || null;
        }

        function addNodeAt(x, y, initialData = null) {
          pushHistory();
          const id = uid();
          const node = {
            id,
            x,
            y,
            w: 320,
            h: 180,
            data: initialData
              ? { ...emptyData(), ...initialData }
              : emptyData(),
          };
          state.nodes.push(node);
          vocabInitNodeSnapshot(node);
          mountNode(node);

          // Ordine corretto: prima riempi il DOM, poi misura e posiziona
          populate(node);
          measure(node);
          positionNode(node);

          // Una rimesura al prossimo frame per font/immagini che arrivano dopo
          scheduleMeasureAfterPopulate(node);

          selectOnlyNodes([id]);
          safeRedrawEdges();
          return id;
        }
        function addNode() {
          const r = stage.getBoundingClientRect();
          const world = toWorld(r.left + 80, r.top + 80);
          return addNodeAt(world.x, world.y);
        }

        function mountNode(node) {
          const el = document.createElement("div");
          el.className = "node";
          el.id = node.id;
          el.innerHTML = `
            <div class="handle in" data-role="in" title="Input"></div>
            <div class="handle out" data-role="out" title="Output / Create child"></div>
            <div class="body">
              <div class="title"></div>
              <div class="divider div-after-title"></div>
              <div class="meta"><span class="date"></span></div>
              <div class="divider div-after-date"></div>
              <div class="kv">
                <div>Type</div><div class="object typeField"></div>
                <div>Action</div><div class="action"></div>
                <div>Main area</div><div class="mainArea"></div>
                <div>Areas</div><div class="areas"></div>
              </div>
              <div class="descBlock">
                <div class="descTitle" style="display:none">Description</div>
                <div class="desc"></div>
              </div>
              <div class="tags"></div>
              <div class="links"></div>
              <div class="images"></div>
              <div class="attachments"></div>
            </div>`;
          stage.appendChild(el);

          // Drag nodo (multi)
          let dragging = false,
            off = { x: 0, y: 0 },
            pushed = false,
            multiOffsets = null;
          el.addEventListener("mousedown", (e) => {
            const role = e.target.getAttribute("data-role");
            if (role) return;
            dragging = true;
            el.classList.add("dragging");
            const w = toWorld(e.clientX, e.clientY);
            off.x = w.x - node.x;
            off.y = w.y - node.y;
            if (!pushed) {
              pushHistory();
              pushed = true;
            }

            if (node.group && !e.shiftKey) {
              const groupNodes = state.nodes
                .filter((n) => n.group === node.group)
                .map((n) => n.id);
              selectOnlyNodes(groupNodes);
            } else {
              if (e.shiftKey) toggleNodeSelection(node.id);
              else if (!state.selNodes.has(node.id)) selectOnlyNodes([node.id]);
            }
            clearEdgeSelection();
            updateSidebarSelectionLabel();
            refreshSidebarForms();

            if (state.selNodes.size > 1) {
              const cur = toWorld(e.clientX, e.clientY);
              multiOffsets = [...state.selNodes].map((id) => {
                const n = getNodeById(id);
                return { id, dx: n.x - cur.x, dy: n.y - cur.y };
              });
            } else multiOffsets = null;
          });
          document.addEventListener("mousemove", (e) => {
            if (!dragging) return;
            const w = toWorld(e.clientX, e.clientY);
            if (multiOffsets) {
              for (const m of multiOffsets) {
                const n = getNodeById(m.id);
                if (!n) continue;
                n.x = w.x + m.dx;
                n.y = w.y + m.dy;
                positionNode(n);
                updateEdgesForNode(n.id);
              }
            } else {
              node.x = w.x - off.x;
              node.y = w.y - off.y;
              positionNode(node);
              updateEdgesForNode(node.id);
            }
            if (typeof scheduleEdgeCanvasDraw === "function")
              scheduleEdgeCanvasDraw();
          });
          document.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              el.classList.remove("dragging");
              if (multiOffsets) {
                for (const m of multiOffsets) {
                  const n = getNodeById(m.id);
                  if (n) {
                    measure(n);
                    markEdgesDirtyForNode(n.id);
                  }
                }
              } else {
                measure(node);
                markEdgesDirtyForNode(node.id);
              }
              pushed = false;
              multiOffsets = null;
              flushDirtyEdges();
            }
          });

          // Handles
          const inEl = el.querySelector(".in"),
            outEl = el.querySelector(".out");
          const handleDown = (side) => (e) => {
            e.stopPropagation();
            const sources =
              state.selNodes.has(node.id) && state.selNodes.size > 1
                ? [...state.selNodes]
                : [node.id];
            state.press = {
              side,
              sources,
              primary: node.id,
              startX: e.clientX,
              startY: e.clientY,
              moved: false,
            };
          };
          const handleUp = (side) => (e) => {
            e.stopPropagation();
            if (state.dragLink && state.dragLink.active) {
              const from = state.dragLink.from;
              if (
                (from === "out" && side === "in") ||
                (from === "in" && side === "out")
              ) {
                pushHistory();
                const targetNodeId = node.id;
                if (from === "out") {
                  for (const s of state.dragLink.sources) {
                    if (s !== targetNodeId) addEdge(s, targetNodeId);
                  }
                } else {
                  for (const t of state.dragLink.sources) {
                    if (t !== targetNodeId) addEdge(targetNodeId, t);
                  }
                }
                cancelGhost();
                renderEdges();
                setStatus("Edge created");
                return;
              }

              // 👇 patch: rilascio sopra un nodo ma non su handle → annulla ghost
              cancelGhost();
              renderEdges();
              setStatus("");
              return;
            }

            if (
              state.press &&
              !state.press.moved &&
              state.press.side === side
            ) {
              if (side === "out") {
                if (!state.dragLink) {
                  pushHistory();
                  const srcs = state.press.sources;
                  for (const sid of srcs) {
                    const parent = getNodeById(sid);
                    if (!parent) continue;
                    const pos = nextChildPosition(parent);
                    const p = parent.data;
                    const init = {
                      type: p.type || "",
                      action: p.action ?? null,
                      mainArea: p.mainArea ?? null,
                      areas: [...(p.areas || [])],
                    };
                    const childId = addNodeAt(pos.x, pos.y, init);
                    addEdge(parent.id, childId);
                  }
                  renderEdges();
                  setStatus(
                    srcs.length > 1
                      ? "Children created and connected"
                      : "Child created and connected"
                  );
                } else {
                  if (state.dragLink.from === "in") {
                    pushHistory();
                    const targetNodeId = node.id;
                    for (const t of state.dragLink.sources) {
                      if (t !== targetNodeId) addEdge(targetNodeId, t);
                    }
                    cancelGhost();
                    renderEdges();
                    setStatus("Edge created");
                  }
                }
              } else {
                if (state.dragLink && state.dragLink.from === "out") {
                  pushHistory();
                  const targetNodeId = node.id;
                  for (const s of state.dragLink.sources) {
                    if (s !== targetNodeId) addEdge(s, targetNodeId);
                  }
                  cancelGhost();
                  renderEdges();
                  setStatus("Edge created");
                }
              }
            }
            state.press = null;
          };
          const handleMove = () => (e) => {
            if (!state.press) return;
            const dx = e.clientX - state.press.startX,
              dy = e.clientY - state.press.startY;
            if (!state.press.moved && Math.hypot(dx, dy) > CLICK_THRESHOLD) {
              state.press.moved = true;
              startGhost(
                state.press.side,
                state.press.sources,
                state.press.primary
              );
            }
            if (state.dragLink && state.dragLink.active) {
              const w = toWorld(e.clientX, e.clientY);
              state.dragLink.x = w.x;
              state.dragLink.y = w.y;

              // Aggancia a handle/nodo sotto il puntatore (senza scan globale)
              const pick = pickDropTargetFromPointer(
                e.clientX,
                e.clientY,
                state.dragLink.from
              );
              state.dragLink.snap = pick || null;

              // Feedback cursore
              stage.style.cursor = pick ? "grab" : "grabbing";

              scheduleEdgeCanvasDraw();
            }
          };
          outEl.addEventListener("mousedown", handleDown("out"));
          inEl.addEventListener("mousedown", handleDown("in"));
          outEl.addEventListener("mouseup", handleUp("out"));
          inEl.addEventListener("mouseup", handleUp("in"));
          // 👇 patch: se rilascio su un nodo ma NON sulla handle → annulla ghost
          el.addEventListener("mouseup", (e) => {
            if (state.dragLink && state.dragLink.active) {
              cancelGhost();
              if (typeof renderEdges === "function") renderEdges();
              if (typeof scheduleEdgeCanvasDraw === "function")
                scheduleEdgeCanvasDraw();
              setStatus("");
              e.stopPropagation();
            }
          });
          document.addEventListener("mousemove", handleMove());
        }

        function startGhost(from, sources, primary) {
          state.dragLink = {
            active: true,
            from,
            sources: [...new Set(sources)],
            primary,
            x: 0,
            y: 0,
            snap: null,
          };
          document.body.style.cursor = "grabbing";
          stage.style.cursor = "grabbing";
          setStatus(from === "out" ? "Drag to input…" : "Drag to output…");
        }
        function cancelGhost() {
          state.dragLink = null;
          state.press = null;
          document.body.style.cursor = "";
          stage.style.cursor = "";
          setStatus("");
        }
        document.addEventListener("mouseup", () => {
          if (state.press) state.press = null;
          if (!(state.dragLink && state.dragLink.active)) {
            document.body.style.cursor = "";
            stage.style.cursor = "";
          }
        });

        // Click su canvas: deseleziona SOLO su sfondo vuoto (stage o edgesSVG “nudo”)
        stage.addEventListener("click", (e) => {
          if (state.ignoreNextStageClick) {
            state.ignoreNextStageClick = false;
            return;
          }
          // se stavo trascinando un ghost-link, annulla ma NON deselezionare
          if (state.dragLink && state.dragLink.active) {
            cancelGhost();
            renderEdges();
            return;
          }
          // Desel. SOLO se: mousedown su vuoto, nessun movimento, e il punto è ancora vuoto
          if (
            bgPointerDown &&
            !gestureMoved &&
            isBlankAtPoint(e.clientX, e.clientY)
          ) {
            finalizeEditsCurrentNode();
            clearAllSelection();
          }
          // reset flags gesto
          bgPointerDown = false;
          gestureMoved = false;
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            if (state.dragLink) {
              cancelGhost();
              scheduleEdgeCanvasDraw();
            } else {
              finalizeEditsCurrentNode();
              clearAllSelection();
            }
          }
        });

        // === Keyboard (Space non “ruba” negli input)
        document.addEventListener("keydown", (e) => {
          const tag = document.activeElement?.tagName;
          const inText =
            tag === "INPUT" ||
            tag === "TEXTAREA" ||
            document.activeElement?.isContentEditable;

          if (e.code === "Space" && !inText) {
            state.spaceDown = true;
            e.preventDefault();
            document.body.classList.add("space-pan");
            stage.style.cursor = "all-scroll";
            return;
          }

          // Cmd/Ctrl + L → Auto layout
          if (
            !inText &&
            (e.metaKey || e.ctrlKey) &&
            e.key.toLowerCase() === "l"
          ) {
            e.preventDefault();
            autoLayoutLeftToRight();
            setStatus("Auto layout");
            return;
          }

          if ((e.metaKey || e.ctrlKey || e.altKey) && !inText) {
            const k = e.key.toLowerCase();
            if (k === "z" && !e.shiftKey) {
              e.preventDefault();
              undo();
              return;
            }
            if ((k === "z" && e.shiftKey) || k === "y") {
              e.preventDefault();
              redo();
              return;
            }
            // RIMOSSO: Cmd/Ctrl+N (nessuna scorciatoia per New Project)
            if (k === "o") {
              e.preventDefault();
              openProject();
              return;
            }
            if (k === "s" && !e.shiftKey) {
              e.preventDefault();
              saveProjectSmart();
              return;
            }
            if (k === "s" && e.shiftKey) {
              e.preventDefault();
              saveAs();
              return;
            }
            if (k === "p") {
              e.preventDefault();
              exportJSON();
              return;
            }
            // RIMOSSO: N con modificatori (nessuna scorciatoia per New Project)
            if (k === "a" && !e.shiftKey) {
              e.preventDefault();
              selectAll();
              return;
            }
            if (k === "a" && e.shiftKey) {
              e.preventDefault();
              finalizeEditsCurrentNode();
              clearAllSelection();
              return;
            }
            if (k === "d" && !e.shiftKey) {
              e.preventDefault();
              duplicateSelection();
              return;
            }
            if (k === "g" && !e.shiftKey) {
              e.preventDefault();
              groupSelection();
              return;
            }
            if (k === "g" && e.shiftKey) {
              e.preventDefault();
              ungroupSelection();
              return;
            }
            if (k === "c") {
              e.preventDefault();
              copySelection();
              return;
            }
            if (k === "x") {
              e.preventDefault();
              cutSelection();
              return;
            }
            if (k === "v") {
              e.preventDefault();
              pasteClipboard();
              return;
            }
          }

          if ((e.key === "Delete" || e.key === "Backspace") && !inText) {
            e.preventDefault();
            doDeleteSelection();
            return;
          }
          if (e.key === "0") {
            e.preventDefault();
            fitView();
            return;
          }
          // (removed old L connect shortcut)

          // W = toggle weak dashed su edge selezionati
          if (e.key.toLowerCase() === "w" && state.selEdges.size) {
            e.preventDefault();
            pushHistory();
            for (const idx of state.selEdges) {
              const edge = getEdgeByIndex(idx);
              if (edge) edge.dashed = !edge.dashed;
            }
            renderEdges();
            return;
          }

          // (removed old L press/hold connect logic in favor of FSM)
        });
        document.addEventListener("keyup", (e) => {
          if (e.code === "Space") {
            state.spaceDown = false;
            document.body.classList.remove("space-pan");
            stage.style.cursor = "";
          }
        });

        function doDeleteSelection() {
          if (state.selEdges.size || state.selNodes.size) pushHistory();
          if (state.selEdges.size) {
            const del = [...state.selEdges].sort((a, b) => b - a);
            del.forEach((i) => state.edges.splice(i, 1));
            state.selEdges.clear();
          }
          if (state.selNodes.size) {
            const ids = [...state.selNodes];
            for (const id of ids) {
              const n = getNodeById(id);
              n && vocabRemoveNode(n);
            }
            state.edges = state.edges.filter(
              (e) => !state.selNodes.has(e.s) && !state.selNodes.has(e.t)
            );
            ids.forEach((id) => document.getElementById(id)?.remove());
            state.nodes = state.nodes.filter((n) => !state.selNodes.has(n.id));
            state.selNodes.clear();

            // ripulisci MRU type “vuoti”
            vocab.typeMRU.removeIf((x) => {
              const k = normalizeToken(x || "");
              return !k || (counts.type.get(k) || 0) <= 0;
            });
          }
          renderEdges();
          scheduleEdgeCanvasDraw();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          clearForm();
        }

        function positionNode(node) {
          const el = $("#" + node.id);
          const p = fromWorld(node.x, node.y);
          el.style.transform = `translate(${p.x}px,${p.y}px) scale(${state.zoom})`;
        }
        function measure(node) {
          const el = $("#" + node.id);
          node.w = el.offsetWidth;
          node.h = el.offsetHeight;
        }

        // Redraw edges: usa canvas se presente, altrimenti SVG
        function safeRedrawEdges() {
          if (typeof scheduleEdgeCanvasDraw === "function") {
            scheduleEdgeCanvasDraw();
          } else if (typeof renderEdges === "function") {
            renderEdges();
          }
        }

        // Pianifica una rimesura subito dopo che il DOM ha dipinto
        function scheduleMeasureAfterPopulate(node) {
          requestAnimationFrame(() => {
            measure(node);
            positionNode(node);
            safeRedrawEdges();
          });
        }

        function renderDescription(htmlEl, text) {
          if (!text) {
            htmlEl.innerHTML = "";
            return;
          }
          // Support paragraphs (blank line) and soft breaks (single \n)
          const normalized = text.replace(/\r\n/g, "\n");
          const blocks = normalized.split(/\n\n+/); // paragraphs
          let out = "";
          for (const block of blocks) {
            const trimmed = block.trimEnd();
            if (!trimmed) {
              out += "<p></p>";
              continue;
            }

            // handle list items inside a block, preserving soft breaks
            const lines = trimmed.split("\n");
            if (lines.every((ln) => /^[-*]\s+/.test(ln.trim()))) {
              out += "<ul>";
              for (const raw of lines) {
                const item = esc(raw.trim().replace(/^[-*]\s+/, ""));
                out += `<li>${item}</li>`;
              }
              out += "</ul>";
            } else {
              // paragraph with soft line breaks as <br>
              const withBr = lines.map((ln) => esc(ln)).join("<br>");
              out += `<p>${withBr}</p>`;
            }
          }
          htmlEl.innerHTML = out;
        }

        function populate(node) {
          const el = $("#" + node.id);
          if (!el) return;
          const d = node.data;
          const hasTitle = !!(d.title && d.title.trim());
          const hasDate = !!(d.date && d.date.trim());
          const titleEl = el.querySelector(".title");
          const dateEl = el.querySelector(".date");
          const divAfterTitle = el.querySelector(".div-after-title");
          const divAfterDate = el.querySelector(".div-after-date");

          if (titleEl) {
            titleEl.textContent = hasTitle ? d.title : "";
            titleEl.style.display = hasTitle ? "block" : "none";
          }
          if (dateEl) {
            dateEl.textContent = formatDateIT(d.date) || "";
          }
          // mostra divider sotto il titolo solo se il titolo esiste
          if (divAfterTitle)
            divAfterTitle.style.display = hasTitle ? "block" : "none";
          // mostra divider sotto la data solo se la data esiste
          if (divAfterDate)
            divAfterDate.style.display = hasDate ? "block" : "none";
          el.querySelector(".typeField").textContent = d.type || "";
          el.querySelector(".action").textContent = d.action || "";
          el.querySelector(".mainArea").textContent = d.mainArea || "";
          el.querySelector(".areas").innerHTML = (d.areas || [])
            .map((a) => `<span class="badge">${esc(a)}</span>`)
            .join("");

          const descTitle = el.querySelector(".descTitle");
          descTitle.style.display = d.desc ? "block" : "none";
          renderDescription(el.querySelector(".desc"), d.desc || "");

          const tagsEl = el.querySelector(".tags");
          tagsEl.innerHTML = (d.tags || [])
            .map((t) => `<span class="badge">${esc(t)}</span>`)
            .join("");

          const linksEl = el.querySelector(".links");
          linksEl.innerHTML = (d.links || [])
            .map((raw) => {
              const url = normalizeURL(raw);
              return url
                ? `<a href="${esc(url)}" target="_blank" rel="noopener">${esc(
                    raw
                  )}</a>`
                : `<span class="muted">${esc(raw)}</span>`;
            })
            .join("");

          const imagesEl = el.querySelector(".images");
          const imgs = (d.files || []).filter((f) => f.isImage);
          imagesEl.innerHTML = imgs
            .map(
              (f) =>
                `<img src="${esc(f.url)}" alt="${esc(
                  f.name
                )}" draggable="false">`
            )
            .join("");

          // Quando le immagini sono cariche, rimesura e riallinea gli anchor
          imagesEl.querySelectorAll("img").forEach((img) => {
            const done = () => {
              measure(node);
              positionNode(node);
              safeRedrawEdges();
            };
            img.addEventListener("load", done, { once: true });
            if (img.decode) {
              img
                .decode()
                .then(done)
                .catch(() => {});
            }
          });

          const attEl = el.querySelector(".attachments");
          const docs = (d.files || []).filter((f) => !f.isImage);
          attEl.innerHTML = docs
            .map((f) => {
              const href = esc(f.url),
                name = esc(f.name);
              return f.isPDF
                ? `<a href="${href}" target="_blank" rel="noopener">${name}</a>`
                : `<a href="${href}" download="${name}">${name}</a>`;
            })
            .join(" ");
        }

        // ==== Forms ====
        function fillFormForNode(node) {
          const d = node?.data || emptyData();
          f.date.value = d.date || "";
          f.title.value = d.title || "";
          f.type.value = d.type || "";
          renderRadioChips(f.actionChips, d.action);
          renderRadioChips(f.mainAreaChips, d.mainArea);
          f.areas.value = (d.areas || []).join(", ");
          f.tags.value = (d.tags || []).join(", ");
          f.desc.value = d.desc || "";
          f.links.value = (d.links || []).join("\n");
          renderFilesList(node);
          f.files.value = "";
          renderSuggestionsForNode(node);
        }
        function clearForm() {
          for (const el of [
            f.date,
            f.title,
            f.type,
            f.areas,
            f.tags,
            f.desc,
            f.links,
          ])
            el.value = "";
          f.filesList.innerHTML = "";
          f.areasChips.innerHTML = "";
          f.tagsChips.innerHTML = "";
          f.typeChips.innerHTML = "";
          renderRadioChips(f.actionChips, null);
          renderRadioChips(f.mainAreaChips, null);
        }

        function renderFilesList(node) {
          const files = node?.data?.files || [];
          if (!files.length) {
            f.filesList.innerHTML = "";
            return;
          }
          f.filesList.innerHTML = files
            .map((file, i) => {
              const name = esc(file.name || "file");
              const size = bytes(file.size || 0);
              const thumb = file.isImage
                ? `<img class="thumb" src="${esc(file.url)}" alt="">`
                : "";
              return `<div class="file-row"><div class="file-left">${thumb}<div class="name">• ${name}${
                size ? " — " + esc(size) : ""
              }</div></div><div class="remove" data-idx="${i}">Remove</div></div>`;
            })
            .join("");
        }

        function updateSidebarSelectionLabel() {
          const n = state.selNodes.size,
            e = state.selEdges.size;
          if (n === 0 && e === 0) {
            f.selInfo.textContent = "No selection";
            return;
          }
          if (n === 1 && e === 0) {
            const id = [...state.selNodes][0];
            const node = getNodeById(id);
            f.selInfo.textContent = `Selected: ${node?.data?.title || id}`;
            return;
          }
          if (n === 0 && e === 1) {
            const i = [...state.selEdges][0];
            const ed = getEdgeByIndex(i);
            f.selInfo.textContent = `Selected edge: ${ed?.s || "?"} → ${
              ed?.t || "?"
            }`;
            return;
          }
          f.selInfo.textContent = `${n} node(s), ${e} edge(s) selected`;
        }
        function refreshSidebarForms() {
          const showNode =
            state.selNodes.size === 1 && state.selEdges.size === 0;
          const showEdge =
            state.selEdges.size === 1 && state.selNodes.size === 0;

          f.nodeForm.style.display = showNode ? "block" : "none";
          f.edgeForm.style.display = showEdge ? "block" : "none";
          if (f.panelTitle) {
            f.panelTitle.textContent = showNode
              ? "Node properties"
              : showEdge
              ? "Edge properties"
              : "";
          }

          // Toggle layout 1-colonna e forza ridisegno stage/SVG
          const appEl = document.querySelector(".app");
          const hidePanel = !(showNode || showEdge);
          if (appEl) appEl.classList.toggle("no-panel", hidePanel);
          if (typeof ensureSVGSize === "function") ensureSVGSize();
          if (typeof updateGrid === "function") updateGrid();
          if (typeof applyView === "function") applyView();

          if (showNode) {
            fillFormForNode(getNodeById([...state.selNodes][0]));
          } else if (!showEdge) {
            clearForm();
          }
          if (showEdge) {
            const idx = [...state.selEdges][0];
            const edge = getEdgeByIndex(idx);
            f.eFrom.textContent = edge?.s || "—";
            f.eTo.textContent = edge?.t || "—";
            f.eDashed.checked = !!edge?.dashed;
          }
        }

        // Radio chips
        function renderRadioChips(container, activeVal) {
          container.querySelectorAll(".chip").forEach((c) => {
            c.classList.toggle(
              "active",
              c.getAttribute("data-val") === activeVal
            );
          });
        }
        function attachRadioChips() {
          f.actionChips.addEventListener("click", (e) => {
            const chip = e.target.closest(".chip");
            if (!chip) return;
            if (state.selNodes.size !== 1) return;
            const node = getNodeById([...state.selNodes][0]);
            const val = chip.getAttribute("data-val");
            const newVal = node.data.action === val ? null : val;
            node.data.action = newVal;
            renderRadioChips(f.actionChips, newVal);
            populate(node);
            measure(node);
            scheduleHistory();
          });
          f.mainAreaChips.addEventListener("click", (e) => {
            const chip = e.target.closest(".chip");
            if (!chip) return;
            if (state.selNodes.size !== 1) return;
            const node = getNodeById([...state.selNodes][0]);
            const val = chip.getAttribute("data-val");
            const newVal = node.data.mainArea === val ? null : val;
            node.data.mainArea = newVal;
            renderRadioChips(f.mainAreaChips, newVal);
            populate(node);
            measure(node);
            scheduleHistory();
          });
        }
        attachRadioChips();

        // ==== Vocabulary / MRU ====
        const MRU_CAP = Infinity;
        const vocab = {
          areasMRU: makeMRU(MRU_CAP),
          tagsMRU: makeMRU(MRU_CAP),
          typeMRU: makeMRU(MRU_CAP),
        };
        const counts = { areas: new Map(), tags: new Map(), type: new Map() };
        const nodeLast = new Map(); // { id -> { type, areas:Set, tags:Set } }

        // nuova funzione globale
        function recomputeTypeCountsAndMRU() {
          // azzera solo i conti Type (non tocchiamo areas/tags)
          counts.type.clear();
          // riconta dai nodi attuali usando gli snapshot normalizzati
          for (const [id, snap] of nodeLast.entries()) {
            const t = snap?.type || "";
            if (t) counts.type.set(t, (counts.type.get(t) || 0) + 1);
          }
          // pota l'MRU Type: tieni solo le voci vive (count>0)
          vocab.typeMRU.removeIf((x) => (counts.type.get(x) || 0) <= 0);
        }

        function makeMRU(cap) {
          const arr = [],
            set = new Set();
          return {
            put(x) {
              if (!x) return;
              const k = (x || "").toLowerCase();
              if (set.has(k)) {
                const i = arr.findIndex((v) => v.toLowerCase() === k);
                if (i > -1) arr.splice(i, 1);
              } else set.add(k);
              arr.unshift(x);
              while (arr.length > cap) {
                const rem = arr.pop();
                set.delete((rem || "").toLowerCase());
              }
            },
            removeIf(pred) {
              for (let i = arr.length - 1; i >= 0; i--) {
                if (pred(arr[i])) {
                  set.delete((arr[i] || "").toLowerCase());
                  arr.splice(i, 1);
                }
              }
            },
            list() {
              return arr.slice();
            },
            clear() {
              arr.length = 0;
              set.clear();
            },
          };
        }
        function pruneTypeMRUOnce() {
          vocab.typeMRU.removeIf((x) => {
            const k = normalizeToken(x || "");
            return !k || (counts.type.get(k) || 0) <= 0;
          });
        }

        function vocabResetNodeSnapshots() {
          nodeLast.clear();
        }
        function vocabInitNodeSnapshot(node) {
          nodeLast.set(node.id, {
            type: normalizeToken(node.data.type || ""),
            areas: new Set(normalizeArray(node.data.areas || [])),
            tags: new Set(normalizeArray(node.data.tags || [])),
          });
        }
        function countsResetAll() {
          counts.areas.clear();
          counts.tags.clear();
          counts.type.clear();
        }
        function vocabIngestNode(node) {
          const snap = nodeLast.get(node.id);
          if (!snap) return;
          if (snap.type) {
            counts.type.set(snap.type, (counts.type.get(snap.type) || 0) + 1);
          }
          for (const a of snap.areas) {
            counts.areas.set(a, (counts.areas.get(a) || 0) + 1);
          }
          for (const t of snap.tags) {
            counts.tags.set(t, (counts.tags.get(t) || 0) + 1);
          }
        }
        function vocabRemoveNode(node) {
          const snap = nodeLast.get(node.id);
          if (!snap) return;
          if (snap.type) {
            const v = (counts.type.get(snap.type) || 0) - 1;
            if (v <= 0) {
              counts.type.delete(snap.type);
              vocab.typeMRU.removeIf(
                (x) => x.toLowerCase() === snap.type.toLowerCase()
              );
            } else counts.type.set(snap.type, v);
          }
          for (const a of snap.areas) {
            const v = (counts.areas.get(a) || 0) - 1;
            if (v <= 0) counts.areas.delete(a);
            else counts.areas.set(a, v);
          }
          for (const t of snap.tags) {
            const v = (counts.tags.get(t) || 0) - 1;
            if (v <= 0) counts.tags.delete(t);
            else counts.tags.set(t, v);
          }
          nodeLast.delete(node.id);
        }

        // ==== Input bindings ====
        function bindLive() {
          f.date.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            const n = getNodeById([...state.selNodes][0]);
            n.data.date = f.date.value || todayYMD();
            populate(n);
            measure(n);
            scheduleHistory();
          });
          f.title.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            const n = getNodeById([...state.selNodes][0]);
            n.data.title = f.title.value;
            populate(n);
            measure(n);
            scheduleHistory();
          });

          /* TYPE: consentiti solo lettere/numeri/spazi/trattini; commit su blur/Enter */
          f.type.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            // consenti solo lettere, numeri, spazi e trattini
            f.type.value = f.type.value.replace(/[^a-zA-Z0-9\- ]/g, "");
            scheduleHistory();
          });
          f.type.addEventListener("blur", () => {
            commitTypeForSelected();
          });
          f.type.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              commitTypeForSelected();
            }
          });

          // AREAS/TAGS: libero; commit su blur/Enter
          f.areas.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            scheduleHistory();
          });
          f.areas.addEventListener("blur", () => {
            commitAreasForSelected();
          });
          f.areas.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              commitAreasForSelected();
            }
          });

          f.tags.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            scheduleHistory();
          });
          f.tags.addEventListener("blur", () => {
            commitTagsForSelected();
          });
          f.tags.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              commitTagsForSelected();
            }
          });

          f.desc.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            const n = getNodeById([...state.selNodes][0]);
            n.data.desc = f.desc.value;
            populate(n);
            measure(n);
            scheduleHistory();
          });

          f.links.addEventListener("input", () => {
            if (state.selNodes.size !== 1) return;
            const n = getNodeById([...state.selNodes][0]);
            const list = (f.links.value || "")
              .split(/\n+/)
              .map((s) => s.trim())
              .filter(Boolean);
            n.data.links = list;
            populate(n);
            measure(n);
            scheduleHistory();
          });

          // Edge dashed
          f.eDashed.addEventListener("change", () => {
            if (!(state.selEdges.size === 1 && state.selNodes.size === 0))
              return;
            pushHistory();
            const idx = [...state.selEdges][0];
            const edge = getEdgeByIndex(idx);
            if (!edge) return;
            edge.dashed = !!f.eDashed.checked;
            // aggiorna subito sia l'SVG di hit che il canvas visivo
            if (typeof renderEdges === "function") renderEdges();
            if (typeof scheduleEdgeCanvasDraw === "function")
              scheduleEdgeCanvasDraw();
          });

          // Files
          f.btnChoose.addEventListener("click", () => {
            // apri il picker solo se ho esattamente 1 nodo selezionato
            if (state.selNodes.size !== 1) {
              setStatus("Select a node to attach files");
              return;
            }
            f.files.click();
          });
          f.files.addEventListener("change", () => {
            if (state.selNodes.size !== 1) return;
            pushHistory();
            const n = getNodeById([...state.selNodes][0]);
            const newEntries = fileListToEntries(f.files.files);
            n.data.files = (n.data.files || []).concat(newEntries);
            f.files.value = "";
            renderFilesList(n);
            populate(n);
            measure(n);
          });
          f.filesList.addEventListener("click", (e) => {
            const rm = e.target.closest(".remove");
            if (!rm) return;
            const idx = Number(rm.getAttribute("data-idx"));
            if (state.selNodes.size !== 1) return;
            pushHistory();
            const n = getNodeById([...state.selNodes][0]);
            n.data.files.splice(idx, 1);
            renderFilesList(n);
            populate(n);
            measure(n);
          });

          $("#btnUndo").addEventListener("click", undo);
          $("#btnRedo").addEventListener("click", redo);
        }
        bindLive();

        // === Commit (Type/Areas/Tags) ===
        function commitTypeForSelected() {
          if (state.selNodes.size !== 1) return;
          const node = getNodeById([...state.selNodes][0]);
          if (!node) return;

          const raw = normalizeToken(f.type.value || "");
          const last = nodeLast.get(node.id);
          const prev = last?.type || "";

          if (prev && prev !== raw) {
            const v = (counts.type.get(prev) || 0) - 1;
            if (v <= 0) {
              counts.type.delete(prev);
              vocab.typeMRU.removeIf(
                (x) => x.toLowerCase() === prev.toLowerCase()
              );
            } else {
              counts.type.set(prev, v);
            }
          }

          if (raw) {
            counts.type.set(raw, (counts.type.get(raw) || 0) + 1);
            vocab.typeMRU.put(raw);
          }

          if (last) last.type = raw;
          node.data.type = raw;
          f.type.value = raw;

          vocab.typeMRU.removeIf((x) => (counts.type.get(x) || 0) <= 0);

          populate(node);
          measure(node);
          renderTypeSuggestions(node);
        }
        function commitAreasForSelected() {
          if (state.selNodes.size !== 1) return;
          const node = getNodeById([...state.selNodes][0]);
          if (!node) return;
          const arr = normalizeArray(splitListComma(f.areas.value || ""));
          const last = nodeLast.get(node.id);
          const prev = last ? new Set(last.areas) : new Set();
          const cur = new Set(arr);
          for (const x of prev) {
            if (!cur.has(x)) {
              const v = (counts.areas.get(x) || 0) - 1;
              if (v <= 0) counts.areas.delete(x);
              else counts.areas.set(x, v);
            }
          }
          for (const x of cur) {
            if (!prev.has(x)) {
              counts.areas.set(x, (counts.areas.get(x) || 0) + 1);
              vocab.areasMRU.put(x);
            }
          }
          if (last) last.areas = cur;
          node.data.areas = [...cur];
          f.areas.value = [...cur].join(", ");
          populate(node);
          measure(node);
          renderSuggestionsForNode(node);
        }
        function commitTagsForSelected() {
          if (state.selNodes.size !== 1) return;
          const node = getNodeById([...state.selNodes][0]);
          if (!node) return;
          const arr = normalizeArray(splitListComma(f.tags.value || ""));
          const last = nodeLast.get(node.id);
          const prev = last ? new Set(last.tags) : new Set();
          const cur = new Set(arr);
          for (const x of prev) {
            if (!cur.has(x)) {
              const v = (counts.tags.get(x) || 0) - 1;
              if (v <= 0) counts.tags.delete(x);
              else counts.tags.set(x, v);
            }
          }
          for (const x of cur) {
            if (!prev.has(x)) {
              counts.tags.set(x, (counts.tags.get(x) || 0) + 1);
              vocab.tagsMRU.put(x);
            }
          }
          if (last) last.tags = cur;
          node.data.tags = [...cur];
          f.tags.value = [...cur].join(", ");
          populate(node);
          measure(node);
          renderSuggestionsForNode(node);
        }

        // Finalizza il nodo corrente su deselect
        function finalizeEditsCurrentNode() {
          if (state.selNodes.size !== 1) return;
          commitTypeForSelected();
          commitAreasForSelected();
          commitTagsForSelected();
        }

        // Suggerimenti
        function renderTypeSuggestions(node) {
          const cur = normalizeToken(node?.data?.type || "");
          const uniq = new Set();
          // Raccogli i type attuali dal grafo
          for (const n of state.nodes) {
            const t = normalizeToken(n?.data?.type || "");
            if (t && t !== cur) uniq.add(t);
          }
          // Ordine stabile e leggibile
          const live = Array.from(uniq).sort((a, b) =>
            a.localeCompare(b, undefined, { sensitivity: "base" })
          );
          // Render chip
          f.typeChips.innerHTML = live
            .map(
              (x) => `<div class="chip" data-val="${esc(x)}">${esc(x)}</div>`
            )
            .join("");
        }
        function renderSuggestionsForNode(node) {
          const curAreas = new Set(normalizeArray(node?.data?.areas || []));
          const areasList = vocab.areasMRU
            .list()
            .filter((x) => (counts.areas.get(x) || 0) > 0 && !curAreas.has(x));
          f.areasChips.innerHTML = areasList
            .map(
              (x) => `<div class="chip" data-val="${esc(x)}">${esc(x)}</div>`
            )
            .join("");

          const curTags = new Set(normalizeArray(node?.data?.tags || []));
          const tagsList = vocab.tagsMRU
            .list()
            .filter((x) => (counts.tags.get(x) || 0) > 0 && !curTags.has(x));
          f.tagsChips.innerHTML = tagsList
            .map(
              (x) => `<div class="chip" data-val="${esc(x)}">${esc(x)}</div>`
            )
            .join("");

          renderTypeSuggestions(node);
        }
        f.areasChips.addEventListener("click", (e) => {
          const chip = e.target.closest(".chip");
          if (!chip) return;
          if (state.selNodes.size !== 1) return;
          const node = getNodeById([...state.selNodes][0]);
          const val = chip.getAttribute("data-val");
          if (!val) return;
          const tokens = new Set(
            normalizeArray(splitListComma(f.areas.value || ""))
          );
          if (!tokens.has(val)) {
            tokens.add(val);
            f.areas.value = [...tokens].join(", ");
            commitAreasForSelected();
          }
        });
        f.tagsChips.addEventListener("click", (e) => {
          const chip = e.target.closest(".chip");
          if (!chip) return;
          if (state.selNodes.size !== 1) return;
          const node = getNodeById([...state.selNodes][0]);
          const val = chip.getAttribute("data-val");
          if (!val) return;
          const tokens = new Set(
            normalizeArray(splitListComma(f.tags.value || ""))
          );
          if (!tokens.has(val)) {
            tokens.add(val);
            f.tags.value = [...tokens].join(", ");
            commitTagsForSelected();
          }
        });
        f.typeChips.addEventListener("click", (e) => {
          const chip = e.target.closest(".chip");
          if (!chip) return;
          if (state.selNodes.size !== 1) return;
          f.type.value = chip.getAttribute("data-val") || "";
          commitTypeForSelected();
          f.type.blur();
        });

        // Selezione helpers
        function refreshNodeSelectionClasses() {
          document.querySelectorAll(".node").forEach((el) => {
            state.selNodes.has(el.id)
              ? el.classList.add("selected")
              : el.classList.remove("selected");
          });
        }
        function applyEdgeSelection() {
          edgesSVG.querySelectorAll(".edge-visible").forEach((p, i) => {
            p.classList.toggle("selected", state.selEdges.has(i));
          });
        }
        function selectOnlyNodes(ids) {
          finalizeEditsCurrentNode();
          state.selNodes = new Set(ids);
          state.selEdges.clear();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          if (ids.length === 1) fillFormForNode(getNodeById(ids[0]));
          else clearForm();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }
        function toggleNodeSelection(id) {
          finalizeEditsCurrentNode();
          if (state.selNodes.has(id)) state.selNodes.delete(id);
          else state.selNodes.add(id);
          refreshNodeSelectionClasses();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
        }
        function selectOnlyEdges(indexes) {
          finalizeEditsCurrentNode();
          state.selEdges = new Set(indexes);
          state.selNodes.clear();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          clearForm();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }
        function toggleEdgeSelection(index) {
          state.selEdges.has(index)
            ? state.selEdges.delete(index)
            : state.selEdges.add(index);
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }
        function clearEdgeSelection() {
          state.selEdges.clear();
          applyEdgeSelection();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }
        function clearAllSelection() {
          finalizeEditsCurrentNode();
          state.selNodes.clear();
          state.selEdges.clear();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          clearForm();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
          {
            const appEl = document.querySelector(".app");
            if (appEl) appEl.classList.add("no-panel");
          }
          if (typeof ensureSVGSize === "function") ensureSVGSize();
          if (typeof updateGrid === "function") updateGrid();
          if (typeof applyView === "function") applyView();
        }
        function selectAll() {
          finalizeEditsCurrentNode();
          state.selNodes = new Set(state.nodes.map((n) => n.id));
          state.selEdges = new Set(state.edges.map((_, i) => i));
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
        }

        // Toolbar
        $("#btnAdd").addEventListener("click", addNode);
        $("#btnDel").addEventListener("click", doDeleteSelection);
        $("#btnFit").addEventListener("click", fitView);
        $("#btnAuto").addEventListener("click", autoLayoutLeftToRight);
        $("#btnOpen").addEventListener("click", openProject);
        $("#btnSave").addEventListener("click", saveProjectSmart);
        const toolbarStatus = [
          { id: "btnAdd", text: "New node" },
          { id: "btnFit", text: "Fit view" },
          { id: "btnAuto", text: "Auto layout" },
          { id: "btnOpen", text: "Open project" },
          { id: "btnSave", text: "Save project" },
          { id: "btnNew", text: "New project" },
          { id: "btnUndo", text: "Undo" },
          { id: "btnRedo", text: "Redo" },
          { id: "btnDel", text: "Delete selection" },
          // NB: btnConnect escluso perché usa status pulsante dedicato
        ];

        toolbarStatus.forEach(({ id, text }) => {
          const b = document.getElementById(id);
          if (!b) return;
          b.addEventListener("click", () => {
            const addTime = id === "btnSave";
            const t =
              addTime && typeof fmtTime10 === "function"
                ? ` — ${fmtTime10()}`
                : "";
            // post-action per mostrare lo stato finale dell’operazione
            setTimeout(() => setStatus(`${text}${t}`), 0);
          });
        });
        document.getElementById("btnNew")?.addEventListener("click", () => {
          saveProjectSmart().then(() => newProject());
        });

        /* Inserire in fondo allo <script> */
        (function setupToolbarTooltip() {
          const tip = document.createElement("div");
          Object.assign(tip.style, {
            position: "fixed",
            left: "0",
            top: "0",
            display: "none",
            background: "#222",
            color: "#fff",
            fontSize: "11px",
            padding: "4px 6px",
            borderRadius: "4px",
            whiteSpace: "nowrap",
            pointerEvents: "none",
            zIndex: "10000",
            boxShadow: "0 2px 10px rgba(0,0,0,0.35)",
          });
          document.body.appendChild(tip);

          const PAD_Y = 6;
          const PAD_X = 8;

          function show(btn) {
            const text =
              btn.getAttribute("data-tip") || btn.getAttribute("title") || "";
            if (!text) return;
            tip.textContent = text;
            tip.style.display = "block";

            const r = btn.getBoundingClientRect();
            let left = r.left; // allineato a sinistra del bottone
            let top = r.bottom + PAD_Y; // sotto al bottone

            tip.style.left = left + "px";
            tip.style.top = top + "px";

            // clamp orizzontale a viewport
            const w = tip.offsetWidth;
            left = Math.max(
              PAD_X,
              Math.min(left, window.innerWidth - w - PAD_X)
            );
            tip.style.left = left + "px";
          }

          function hide() {
            tip.style.display = "none";
          }

          const buttons = document.querySelectorAll("header button[data-tip]");
          buttons.forEach((btn) => {
            btn.addEventListener("mouseenter", () => show(btn));
            btn.addEventListener("mouseleave", hide);
            btn.addEventListener("blur", hide);
          });

          window.addEventListener("scroll", hide, { passive: true });
          window.addEventListener("resize", hide);
        })();
        // (old connect handler removed in favor of FSM)

        // Pan / Marquee / Zoom
        let panning = false,
          startPan = { x: 0, y: 0 };
        stage.addEventListener("mousedown", (e) => {
          // i <path> degli edge hanno la loro gestione
          if (e.target.tagName === "path") return;

          // Se ho space premuto → pan diretto, anche sopra nodi
          if (state.spaceDown) {
            panning = true;
            stage.style.cursor = "all-scroll";
            const r = stage.getBoundingClientRect();
            startPan = {
              x: e.clientX - r.left - state.pan.x,
              y: e.clientY - r.top - state.pan.y,
            };
            return;
          }

          // Altrimenti: drag in vuoto = marquee
          bgPointerDown = isBlankAtPoint(e.clientX, e.clientY);
          gestureMoved = false;

          if (bgPointerDown) {
            stage._downX = e.clientX;
            stage._downY = e.clientY;
            // niente più _downShift: la modalità si decide in startMarquee() su evento reale
          }
        });

        document.addEventListener("mousemove", (e) => {
          // Failsafe: se un gesto è "attivo" ma il bottone non è più premuto, chiudi
          if ((panning || state.marquee?.active) && e.buttons === 0) {
            if (panning) {
              panning = false;
              stage.style.cursor = "";
            }
            if (state.marquee?.active) {
              endMarquee();
            }
            bgPointerDown = false;
            gestureMoved = false;
            stage._downX = stage._downY = null;
            return;
          }

          // Se il down è nato sul vuoto e nessun gesto è ancora attivo → valuta soglia
          if (bgPointerDown && !panning && !state.marquee?.active) {
            const ox = stage._downX,
              oy = stage._downY;
            const dist =
              Number.isFinite(ox) && Number.isFinite(oy)
                ? Math.hypot(e.clientX - ox, e.clientY - oy)
                : 0;

            if (dist > CLICK_THRESHOLD) {
              // Default: marquee senza Shift; se l'utente tiene Shift, startMarquee leggerà shiftKey
              startMarquee({
                clientX: ox,
                clientY: oy,
                shiftKey: e.shiftKey,
              });
              gestureMoved = true;
              return;
            }
          }

          // Pan attivo (space o trackpad)
          if (panning) {
            const r = stage.getBoundingClientRect();
            state.pan.x = e.clientX - r.left - startPan.x;
            state.pan.y = e.clientY - r.top - startPan.y;
            applyView();
            gestureMoved = true;
            return;
          }

          // Marquee attiva
          if (state.marquee?.active) {
            updateMarquee(e);
            gestureMoved = true;
            return;
          }
        });
        document.addEventListener("mouseup", () => {
          if (panning) {
            panning = false;
            stage.style.cursor = "";
          }
          if (state.marquee?.active) {
            endMarquee();
          }
          stage._downX = stage._downY = null;
        });
        stage.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();

            // Se pinch/zoom (ctrlKey attivo) → zoom
            if (e.ctrlKey) {
              const sensitivity = 0.012,
                d = -e.deltaY * sensitivity,
                old = state.zoom;
              const z = Math.min(3, Math.max(0.25, old * (1 + d)));
              const r = stage.getBoundingClientRect();
              const mx = e.clientX - r.left,
                my = e.clientY - r.top;
              const wx = (mx - state.pan.x) / old,
                wy = (my - state.pan.y) / old;
              state.zoom = z;
              state.pan.x = mx - wx * z;
              state.pan.y = my - wy * z;
              applyView();
              return;
            }

            // Altrimenti → pan con due dita trackpad
            state.pan.x -= e.deltaX;
            state.pan.y -= e.deltaY;
            applyView();
          },
          { passive: false }
        );

        function applyView() {
          ensureSVGSize();
          updateGrid();
          state.nodes.forEach((n) => positionNode(n));
          // ricalcola le geometrie degli edge già presenti
          for (let i = 0; i < state.edges.length; i++) {
            const ed = state.edges[i];
            const s = anchor(ed.s, "right");
            const t = anchor(ed.t, "left");
            if (!s || !t) continue;
            updateEdgePathsD(i, pathCubic(s, t));
          }
          // Canvas per la resa visiva
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }
        function fitView() {
          if (!state.nodes.length) {
            state.zoom = 1;
            state.pan = { x: 0, y: 0 };
            applyView();
            return;
          }
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          for (const n of state.nodes) {
            minX = Math.min(minX, n.x);
            minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x + (n.w || NODE_W));
            maxY = Math.max(maxY, n.y + (n.h || NODE_H));
          }
          const r = stage.getBoundingClientRect(),
            vw = r.width,
            vh = r.height;
          const bw = maxX - minX,
            bh = maxY - minY,
            m = 80;
          const zx = (vw - m) / bw,
            zy = (vh - m) / bh;
          state.zoom = Math.min(3, Math.max(0.25, Math.min(zx, zy)));
          const cx = (minX + maxX) / 2,
            cy = (minY + maxY) / 2;
          state.pan.x = vw / 2 - cx * state.zoom;
          state.pan.y = vh / 2 - cy * state.zoom;
          applyView();
        }

        function startMarquee(e) {
          document.body.classList.add("marquee-active");
          const rect = document.createElement("div");
          rect.className = "marquee";
          stage.appendChild(rect);
          const r = stage.getBoundingClientRect();
          state.marquee = {
            active: true,
            startX: e.clientX - r.left,
            startY: e.clientY - r.top,
            curX: e.clientX - r.left,
            curY: e.clientY - r.top,
            el: rect,
            // Modalità: di default "replace"; con Shift → "toggle"
            mode: e.shiftKey ? "toggle" : "replace",
            prevNodes: new Set(state.selNodes),
            prevEdges: new Set(state.selEdges),
          };
          state.ignoreNextStageClick = true;
          drawMarqueeRect();
        }
        function updateMarquee(e) {
          const r = stage.getBoundingClientRect();
          state.marquee.curX = e.clientX - r.left;
          state.marquee.curY = e.clientY - r.top;
          drawMarqueeRect();
          const a = toWorld(
            state.marquee.startX + r.left,
            state.marquee.startY + r.top
          );
          const b = toWorld(
            state.marquee.curX + r.left,
            state.marquee.curY + r.top
          );
          const minX = Math.min(a.x, b.x),
            minY = Math.min(a.y, b.y),
            maxX = Math.max(a.x, b.x),
            maxY = Math.max(a.y, b.y);

          // SOLO NODI (niente edge nella marquee)
          const hitsNodes = new Set(
            state.nodes
              .filter((n) =>
                rectsIntersect(
                  minX,
                  minY,
                  maxX,
                  maxY,
                  n.x,
                  n.y,
                  n.x + (n.w || NODE_W),
                  n.y + (n.h || NODE_H)
                )
              )
              .map((n) => n.id)
          );

          if (state.marquee.mode === "toggle") {
            // XOR tra selezione precedente e nodi “colpiti”
            const next = new Set(state.marquee.prevNodes);
            for (const id of hitsNodes) {
              if (next.has(id)) next.delete(id);
              else next.add(id);
            }
            state.selNodes = next;
            // mantieni gli edge com’erano (non tocchiamo gli edge in marquee)
            state.selEdges = new Set(state.marquee.prevEdges);
          } else {
            // replace (default): seleziona solo i nodi colpiti, nessun edge
            state.selNodes = hitsNodes;
            state.selEdges = new Set();
          }
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          if (state.selNodes.size === 1 && state.selEdges.size === 0)
            fillFormForNode(getNodeById([...state.selNodes][0]));
          else clearForm();
        }
        function endMarquee() {
          state.marquee.el.remove();
          state.marquee = null;
          document.body.classList.remove("marquee-active");
        }
        function drawMarqueeRect() {
          const m = state.marquee;
          if (!m) return;
          const x = Math.min(m.startX, m.curX),
            y = Math.min(m.startY, m.curY);
          const w = Math.abs(m.curX - m.startX),
            h = Math.abs(m.curY - m.startY);
          m.el.style.left = x + "px";
          m.el.style.top = y + "px";
          m.el.style.width = w + "px";
          m.el.style.height = h + "px";
        }
        function rectsIntersect(
          aMinX,
          aMinY,
          aMaxX,
          aMaxY,
          bMinX,
          bMinY,
          bMaxX,
          bMaxY
        ) {
          return (
            aMinX <= bMaxX && aMaxX >= bMinX && aMinY <= bMaxY && aMaxY >= bMinY
          );
        }

        // Auto layout
        function autoLayoutLeftToRight() {
          pushHistory();
          state.nodes.forEach((n) => measure(n));
          const indeg = new Map(state.nodes.map((n) => [n.id, 0]));
          state.edges.forEach((e) => indeg.set(e.t, (indeg.get(e.t) || 0) + 1));
          const roots = state.nodes
            .filter((n) => (indeg.get(n.id) || 0) === 0)
            .map((n) => n.id);
          const depth = new Map();
          const q = [...roots];
          roots.forEach((id) => depth.set(id, 0));
          while (q.length) {
            const u = q.shift();
            const d = depth.get(u) || 0;
            state.edges
              .filter((e) => e.s === u)
              .forEach((e) => {
                if (!depth.has(e.t)) {
                  depth.set(e.t, d + 1);
                  q.push(e.t);
                }
              });
          }
          state.nodes.forEach((n) => {
            if (!depth.has(n.id)) depth.set(n.id, 0);
          });
          const layers = {};
          state.nodes.forEach((n) => {
            const d = depth.get(n.id) || 0;
            (layers[d] ||= []).push(n);
          });
          const layerKeys = Object.keys(layers)
            .map(Number)
            .sort((a, b) => a - b);
          let x = 0;
          layerKeys.forEach((li) => {
            const col = layers[li];
            col.sort((a, b) => a.y - b.y);
            let y = 0;
            for (const n of col) {
              n.x = x;
              n.y = y;
              const h = n.h || NODE_H;
              y += h + Math.max(VGAP, MIN_LAYER_GAP);
            }
            x += NODE_W + HGAP;
          });
          state.nodes.forEach((n) => positionNode(n));
          renderEdges();
          scheduleEdgeCanvasDraw();
          setStatus("Auto layout applied");
        }
        function nextChildPosition(parent) {
          const children = state.edges
            .filter((e) => e.s === parent.id)
            .map((e) => getNodeById(e.t))
            .filter(Boolean);
          const baseX = parent.x + (parent.w || NODE_W) + HGAP;
          if (children.length === 0) return { x: baseX, y: parent.y };
          const last = children.reduce(
            (a, c) => (c.y > a.y ? c : a),
            children[0]
          );
          return { x: baseX, y: last.y + (last.h || NODE_H) + VGAP };
        }

        function addEdge(s, t) {
          if (!s || !t || s === t) return;
          if (state.edges.some((e) => e.s === s && e.t === t)) return;
          state.edges.push({ s, t, dashed: false });
          // Ricostruisci l’SVG dei path-hit per abilitare click/selection
          if (typeof renderEdges === "function") renderEdges();
          // Ridisegna il canvas (vista)
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }
        // Dirty set per update mirati degli edge
        const dirtyEdges = new Set();
        function markEdgesDirtyForNode(nodeId) {
          for (let i = 0; i < state.edges.length; i++) {
            const ed = state.edges[i];
            if (ed.s === nodeId || ed.t === nodeId) dirtyEdges.add(i);
          }
        }
        let edgeRafScheduled = false;
        function flushDirtyEdges() {
          if (edgeRafScheduled) return;
          edgeRafScheduled = true;
          requestAnimationFrame(() => {
            edgeRafScheduled = false;
            if (!dirtyEdges.size) return;
            for (const i of dirtyEdges) {
              const ed = state.edges[i];
              if (!ed) continue;
              const s = anchor(ed.s, "right");
              const t = anchor(ed.t, "left");
              if (!s || !t) continue;
              updateEdgePathsD(i, pathCubic(s, t));
            }
            dirtyEdges.clear();
          });
        }
        function anchor(id, side) {
          const n = getNodeById(id);
          if (!n) return { x: 0, y: 0 };
          const x = side === "right" ? n.x + (n.w || NODE_W) : n.x;
          const y = n.y + (n.h || NODE_H) / 2;
          return { x, y };
        }
        // Ritorna target dal puntatore: handle o nodo compatibile, altrimenti null
        // fromSide: "out" cerca target lato "left"; "in" cerca target lato "right"
        function pickDropTargetFromPointer(clientX, clientY, fromSide) {
          const el = document.elementFromPoint(clientX, clientY);
          if (!el) return null;

          const handle = el.classList?.contains?.("handle")
            ? el
            : el.closest?.(".handle");
          const wantAnchorSide = fromSide === "out" ? "left" : "right";

          if (handle) {
            const nodeEl = handle.closest(".node");
            if (nodeEl?.id) {
              const a = anchor(nodeEl.id, wantAnchorSide);
              return {
                nodeId: nodeEl.id,
                side: wantAnchorSide,
                wx: a.x,
                wy: a.y,
              };
            }
          }

          const nodeEl = el.classList?.contains?.("node")
            ? el
            : el.closest?.(".node");
          if (nodeEl?.id) {
            const a = anchor(nodeEl.id, wantAnchorSide);
            return {
              nodeId: nodeEl.id,
              side: wantAnchorSide,
              wx: a.x,
              wy: a.y,
            };
          }

          return null;
        }
        // Raggio di snap in pixel schermo (indipendente dallo zoom)
        const SNAP_PX = 18;
        // Trova handle compatibile più vicino a worldX/worldY
        function findNearestCompatibleHandle(
          worldX,
          worldY,
          fromSide,
          excludeNodeIds = []
        ) {
          const wantSide = fromSide === "out" ? "left" : "right";
          const excl = new Set(excludeNodeIds || []);
          let best = null;
          let bestDist = Infinity;
          const p = fromWorld(worldX, worldY);
          for (const n of state.nodes) {
            if (!n) continue;
            if (excl.has(n.id)) continue;
            const a = anchor(n.id, wantSide);
            const s = fromWorld(a.x, a.y);
            const dist = Math.hypot(s.x - p.x, s.y - p.y);
            if (dist <= SNAP_PX && dist < bestDist) {
              bestDist = dist;
              best = {
                nodeId: n.id,
                side: wantSide,
                wx: a.x,
                wy: a.y,
                sx: s.x,
                sy: s.y,
              };
            }
          }
          return best;
        }
        function pathCubic(a, b) {
          const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
          return `M ${a.x} ${a.y} C ${a.x + dx} ${a.y}, ${b.x - dx} ${b.y}, ${
            b.x
          } ${b.y}`;
        }
        // SVG edge helpers
        function getEdgeGroupByIndex(i) {
          return edgesSVG.querySelector(`g[data-idx="${i}"]`);
        }
        function updateEdgePathsD(i, d) {
          const g = getEdgeGroupByIndex(i);
          if (!g) return;
          g.querySelectorAll("path").forEach((p) => p.setAttribute("d", d));
        }
        function updateEdgesForNode(nodeId) {
          for (let i = 0; i < state.edges.length; i++) {
            const ed = state.edges[i];
            if (ed.s === nodeId || ed.t === nodeId) {
              const s = anchor(ed.s, "right");
              const t = anchor(ed.t, "left");
              if (!s || !t) continue;
              const d = pathCubic(s, t);
              updateEdgePathsD(i, d);
            }
          }
        }
        function edgeBBox(e) {
          const s = anchor(e.s, "right"),
            t = anchor(e.t, "left");
          const minX = Math.min(s.x, t.x),
            maxX = Math.max(s.x, t.x),
            minY = Math.min(s.y, t.y),
            maxY = Math.max(s.y, t.y);
          return { minX, minY, maxX, maxY };
        }

        // scheduler per edge rendering
        let __edgeRenderQueued = false;
        function requestEdgeRender() {
          if (__edgeRenderQueued) return;
          __edgeRenderQueued = true;
          requestAnimationFrame(() => {
            __edgeRenderQueued = false;
            renderEdges();
          });
        }

        function renderEdges() {
          ensureSVGSize();
          edgesSVG.innerHTML = "";
          state.edges.forEach((e, i) => {
            const s = anchor(e.s, "right"),
              t = anchor(e.t, "left");
            if (!s || !t) return;
            const g = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            g.setAttribute("data-idx", String(i));
            const pv = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            pv.setAttribute("d", pathCubic(s, t));
            pv.setAttribute(
              "class",
              "edge-visible" + (e.dashed ? " weak" : "")
            );
            if (state.selEdges.has(i)) pv.classList.add("selected");
            g.addEventListener("click", (ev) => {
              ev.stopPropagation();

              // SHIFT → split con nodo copia (tutto tranne desc e files)
              if (ev.shiftKey) {
                pushHistory();
                const mid = { x: (s.x + t.x) / 2, y: (s.y + t.y) / 2 };
                const srcNode = getNodeById(e.s);
                const d = srcNode?.data || {};
                const init = {
                  date: d.date || todayYMD(),
                  title: d.title || "",
                  type: d.type || "",
                  action: d.action ?? null,
                  mainArea: d.mainArea ?? null,
                  areas: [...(d.areas || [])],
                  tags: [...(d.tags || [])],
                  desc: "",
                  links: [...(d.links || [])],
                  files: [],
                };
                const nid = addNodeAt(
                  mid.x - NODE_W / 2,
                  mid.y - NODE_H / 2,
                  init
                );
                const dashed = !!e.dashed;
                state.edges.splice(i, 1);
                state.edges.push(
                  { s: e.s, t: nid, dashed },
                  { s: nid, t: e.t, dashed }
                );
                if (typeof renderEdges === "function") renderEdges();
                if (typeof scheduleEdgeCanvasDraw === "function")
                  scheduleEdgeCanvasDraw();
                return;
              }

              // ALT → split con nodo vuoto (comportamento precedente)
              if (ev.altKey) {
                pushHistory();
                const mid = { x: (s.x + t.x) / 2, y: (s.y + t.y) / 2 };
                const nid = addNodeAt(
                  mid.x - NODE_W / 2,
                  mid.y - NODE_H / 2,
                  {}
                );
                const dashed = !!e.dashed;
                state.edges.splice(i, 1);
                state.edges.push(
                  { s: e.s, t: nid, dashed },
                  { s: nid, t: e.t, dashed }
                );
                if (typeof renderEdges === "function") renderEdges();
                if (typeof scheduleEdgeCanvasDraw === "function")
                  scheduleEdgeCanvasDraw();
                return;
              }

              // Click normale → selezione
              if (ev.shiftKey) {
                toggleEdgeSelection(i);
              } else {
                selectOnlyEdges([i]);
              }
              if (typeof scheduleEdgeCanvasDraw === "function")
                scheduleEdgeCanvasDraw();
            });

            g.appendChild(pv);
            edgesSVG.appendChild(g);
          });

          if (state.dragLink && state.dragLink.active) {
            const t = state.dragLink.snap
              ? { x: state.dragLink.snap.wx, y: state.dragLink.snap.wy }
              : { x: state.dragLink.x, y: state.dragLink.y };
            for (const sid of state.dragLink.sources) {
              const fromAnchor =
                state.dragLink.from === "out"
                  ? anchor(sid, "right")
                  : anchor(sid, "left");
              const a = state.dragLink.from === "out" ? fromAnchor : t;
              const b = state.dragLink.from === "out" ? t : fromAnchor;
              const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );
              path.setAttribute("d", pathCubic(a, b));
              path.setAttribute("stroke", "#fff");
              path.setAttribute("stroke-width", "2");
              path.setAttribute("fill", "none");
              edgesSVG.appendChild(path);
            }
          }
        }

        /* ---------- FAST SAVE HELPERS ---------- */
        async function asyncPool(limit, tasks, worker) {
          const ret = [],
            executing = new Set();
          for (const t of tasks) {
            const p = Promise.resolve().then(() => worker(t));
            ret.push(p);
            executing.add(p);
            p.finally(() => executing.delete(p));
            if (executing.size >= limit) await Promise.race(executing);
          }
          return Promise.all(ret);
        }
        function extFromName(name) {
          const m = (name || "").match(/\.[a-z0-9]+$/i);
          return m ? m[0].toLowerCase() : "";
        }

        /* ---------- SAVE / OPEN (veloce per grafi grandi) ---------- */
        async function saveProjectSmart() {
          if (projectCtx.mode === "folder" && projectCtx.dirHandle) {
            await saveProjectToDir(projectCtx.dirHandle);
            setStatus(`Project saved — ${fmtTime10()}`);
            return;
          }
          await saveAs();
        }
        async function saveAs() {
          const supportsFS = "showDirectoryPicker" in window;
          if (supportsFS) {
            try {
              const dir = await window.showDirectoryPicker({
                mode: "readwrite",
              });
              await saveProjectToDir(dir);
              projectCtx.mode = "folder";
              projectCtx.dirHandle = dir;
              setStatus(`Project saved (new fast folder) — ${fmtTime10()}`);
              return;
            } catch (err) {
              console.warn(
                "Save As cancelled or failed, falling back to light JSON",
                err
              );
            }
          }
          await exportJSONLight(); // fallback leggero (senza file)
          projectCtx.mode = "embedded";
          projectCtx.dirHandle = null;
        }

        // filesMode: "none" | "paths" | "embedded" (noi usiamo "paths" o "none")
        function buildProjectObject(baseVersion = 6, filesMode = "paths") {
          const nodesOut = state.nodes.map((n) => {
            const src = n.data || {};
            const outFiles = (() => {
              if (filesMode === "none") return [];
              if (filesMode === "paths") {
                return (src.files || []).map((f) => ({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  isImage: !!f.isImage,
                  isPDF: !!f.isPDF,
                  path: f.path || null,
                }));
              }
              return (src.files || []).map((f) => ({
                name: f.name,
                size: f.size,
                type: f.type,
                isImage: !!f.isImage,
                isPDF: !!f.isPDF,
                dataUrl: f.dataUrl || null,
              }));
            })();

            return {
              id: n.id,
              x: n.x,
              y: n.y,
              w: n.w,
              h: n.h,
              group: n.group || null,
              data: {
                date: src.date || todayYMD(),
                title: src.title || "",
                type: src.type || "",
                action: src.action ?? null,
                mainArea: src.mainArea ?? null,
                areas: [...(src.areas || [])],
                tags: [...(src.tags || [])],
                desc: src.desc || "",
                links: [...(src.links || [])],
                files: outFiles,
              },
            };
          });

          const vocabOut = {
            areas: vocab.areasMRU.list(),
            tags: vocab.tagsMRU.list(),
            type: vocab.typeMRU.list(),
          };
          return {
            version: baseVersion,
            nodes: nodesOut,
            edges: state.edges.map((e) => ({
              s: e.s,
              t: e.t,
              dashed: !!e.dashed,
            })),
            vocab: vocabOut,
          };
        }

        async function saveProjectToDir(dir) {
          await ensureSubdir(dir, "assets");
          // 1) Copia solo i NUOVI file (quelli già con path si saltano)
          const toCopy = [];
          for (const n of state.nodes) {
            for (const f of n.data.files || []) {
              if (f.path) {
                continue;
              } // già su disco
              toCopy.push({ node: n, file: f });
            }
          }

          /* Dentro a saveProjectToDir(dir): nuova copia con compressione immagini + stato */
          const total = toCopy.length;
          let done = 0;

          if (total > 0) {
            setStatus("Saving assets (0/" + total + ")");
          }

          await asyncPool(2, toCopy, async ({ file }) => {
            try {
              let blob = await fetch(file.url).then((r) => r.blob());

              const baseName = sanitizeName(
                (file.name || "file").replace(/\s+/g, "_")
              );
              const noExt = baseName.replace(/\.[a-z0-9]+$/i, "");
              let finalName, rel;

              if (file.isImage) {
                // Ricompressione a JPG 1500px lato lungo
                const jpg = await resizeImageBlob(blob, 1500, 512 * 1024);
                finalName = `${noExt}.jpg`;
                rel = `assets/${finalName}`;
                await writeFileByPath(dir, rel, jpg);
              } else {
                const ext =
                  extFromName(baseName) || (file.isPDF ? ".pdf" : ".bin");
                finalName = extFromName(baseName)
                  ? baseName
                  : `${baseName}${ext}`;
                rel = `assets/${finalName}`;
                await writeFileByPath(dir, rel, blob);
              }

              file.path = rel;
              delete file.dataUrl;
            } catch (e) {
              console.warn("Copy failed:", file?.name, e);
            } finally {
              done++;
              setStatus(`Saving assets (${done}/${total})`);
            }
          });

          // 2) Scrivi JSON con soli path (niente dataUrl)
          const project = buildProjectObject(6, "paths");
          const jsonBlob = new Blob([JSON.stringify(project, null, 2)], {
            type: "application/json",
          });
          await writeFileByPath(dir, "project.json", jsonBlob);
        }

        async function exportJSONLight() {
          const light = buildProjectObject(6, "none"); // nessun file
          const blob = new Blob([JSON.stringify(light, null, 2)], {
            type: "application/json",
          });
          downloadBlob("project_light.json", blob);
          setStatus(`Light JSON exported (no images) — ${fmtTime10()}`);
        }
        async function exportJSON() {
          await exportJSONLight();
        }

        async function openProject() {
          const supportsFS = "showDirectoryPicker" in window;
          if (supportsFS) {
            try {
              const dir = await window.showDirectoryPicker({
                mode: "readwrite",
              });
              let fileHandle;
              try {
                fileHandle = await dir.getFileHandle("project.json", {
                  create: false,
                });
              } catch {
                setStatus("project.json not found in selected folder");
                return;
              }
              const file = await fileHandle.getFile();
              const project = JSON.parse(await file.text());
              pushHistory();
              await loadProject(project, dir);
              projectCtx.mode = "folder";
              projectCtx.dirHandle = dir;
              setStatus("Project opened from folder");
              return;
            } catch (err) {
              console.warn("FS open error, falling back to JSON input", err);
            }
          }
          f.openFile.onchange = async () => {
            const fl = f.openFile.files?.[0];
            if (!fl) return;
            const text = await fl.text();
            const project = JSON.parse(text);
            pushHistory();
            await loadProject(project, null);
            projectCtx.mode = "embedded";
            projectCtx.dirHandle = null;
            setStatus("Project opened from JSON file");
            f.openFile.value = "";
          };
          f.openFile.click();
        }

        async function newProject() {
          pushHistory();
          finalizeEditsCurrentNode();
          clearAllSelection();
          document.querySelectorAll(".node").forEach((n) => n.remove());
          state.nodes = [];
          state.edges = [];
          /* pulizia immediata della canvas e dell’SVG degli edge */
          if (typeof renderEdges === "function") renderEdges();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
          state.pan = { x: 0, y: 0 };
          state.zoom = 1;
          projectCtx.mode = null;
          projectCtx.dirHandle = null;
          vocab.areasMRU.clear();
          vocab.tagsMRU.clear();
          vocab.typeMRU.clear();
          countsResetAll();
          vocabResetNodeSnapshots();

          // sync MRU type
          vocab.typeMRU.removeIf((x) => {
            const k = normalizeToken(x || "");
            return !k || (counts.type.get(k) || 0) <= 0;
          });

          addNodeAt(80, 80, {});
          setStatus("New project");
        }

        async function loadProject(project, dirHandle) {
          finalizeEditsCurrentNode();
          clearAllSelection();
          document.querySelectorAll(".node").forEach((n) => n.remove());
          state.nodes = [];
          state.edges = [];
          vocabResetNodeSnapshots();
          countsResetAll();

          for (const pn of project.nodes || []) {
            const node = {
              id: pn.id || uid(),
              x: pn.x || 0,
              y: pn.y || 0,
              w: pn.w || NODE_W,
              h: pn.h || NODE_H,
              group: pn.group || null,
              data: emptyData(),
            };
            const d = pn.data || {};
            node.data.type = normalizeToken(d.type || d.object || "");
            if (Array.isArray(d.action)) node.data.action = d.action[0] || null;
            else node.data.action = d.action ?? null;
            if (Array.isArray(d.mainAreas))
              node.data.mainArea = d.mainAreas[0] || null;
            else node.data.mainArea = d.mainArea ?? d.mainarea ?? null;
            node.data.date = d.date || todayYMD();
            node.data.title = d.title || "";
            node.data.areas = normalizeArray(d.areas || []);
            node.data.tags = normalizeArray(d.tags || []);
            node.data.desc = d.desc || "";
            node.data.links = (d.links || []).slice();
            node.data.files = await Promise.all(
              (d.files || []).map(async (f) => {
                if (f.dataUrl) {
                  const blob = await (await fetch(f.dataUrl)).blob();
                  return { ...f, url: URL.createObjectURL(blob) };
                } else if (f.path && dirHandle) {
                  const file = await readFileByPath(dirHandle, f.path);
                  return { ...f, url: URL.createObjectURL(file) };
                } else {
                  return { ...f, url: "" };
                }
              })
            );

            state.nodes.push(node);
            vocabInitNodeSnapshot(node);
            vocabIngestNode(node);

            mountNode(node);
            // Ordine corretto: populate -> measure -> position
            populate(node);
            measure(node);
            positionNode(node);
            // rAF per allineare font/immagini
            scheduleMeasureAfterPopulate(node);
          }
          state.edges = (project.edges || []).map((e) => ({
            s: e.s,
            t: e.t,
            dashed: !!e.dashed,
          }));

          if (project.vocab) {
            vocab.areasMRU.clear();
            vocab.tagsMRU.clear();
            vocab.typeMRU.clear();
            for (const a of project.vocab.areas || [])
              if (a) vocab.areasMRU.put(normalizeToken(a));
            for (const t of project.vocab.tags || [])
              if (t) vocab.tagsMRU.put(normalizeToken(t));
            for (const ty of project.vocab.type || [])
              if (ty) vocab.typeMRU.put(normalizeToken(ty));
            vocab.areasMRU.removeIf((x) => (counts.areas.get(x) || 0) <= 0);
            vocab.tagsMRU.removeIf((x) => (counts.tags.get(x) || 0) <= 0);
          }

          // sync MRU type
          vocab.typeMRU.removeIf((x) => {
            const k = normalizeToken(x || "");
            return !k || (counts.type.get(k) || 0) <= 0;
          });

          ensureSVGSize();
          updateGrid();
          // Prima costruisci i path di hit nello SVG, poi ridisegna il canvas
          if (typeof renderEdges === "function") renderEdges();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
        }

        function undo() {
          if (!history.undo.length) return;
          const cur = snap();
          const prev = history.undo.pop();
          history.redo.push(cur);
          applySnapshot(prev);
          setStatus("Undone");
        }
        function redo() {
          if (!history.redo.length) return;
          const cur = snap();
          const next = history.redo.pop();
          history.undo.push(cur);
          applySnapshot(next);
          setStatus("Redone");
        }
        function applySnapshot(s) {
          history.lock = true;
          document.querySelectorAll(".node").forEach((n) => n.remove());
          state.nodes = structuredClone(s.nodes || []);
          state.edges = structuredClone(s.edges || []);
          state.selNodes = new Set(s.selNodes || []);
          state.selEdges = new Set(s.selEdges || []);
          state.pan = s.pan ? { ...s.pan } : { x: 0, y: 0 };
          state.zoom = s.zoom ?? 1;

          vocabResetNodeSnapshots();
          countsResetAll();

          state.nodes.forEach((n) => {
            mountNode(n);
            // Ordine corretto: populate -> measure -> position
            populate(n);
            measure(n);
            positionNode(n);
            // rAF per allineare eventuali asset
            scheduleMeasureAfterPopulate(n);

            vocabInitNodeSnapshot(n);
            vocabIngestNode(n);
          });

          // Sync MRU Type con i count vivi
          vocab.typeMRU.removeIf((x) => {
            const k = normalizeToken(x || "");
            return !k || (counts.type.get(k) || 0) <= 0;
          });

          ensureSVGSize();
          updateGrid();
          // Ricostruisci l'SVG dei path di hit e aggiorna il canvas
          if (typeof renderEdges === "function") renderEdges();
          if (typeof scheduleEdgeCanvasDraw === "function")
            scheduleEdgeCanvasDraw();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          history.lock = false;
        }

        // Clipboard/group
        let pasteCount = 0;
        function copySelection() {
          if (!state.selNodes.size) return;
          pasteCount = 0;
          const ids = [...state.selNodes];
          const nodes = ids.map((id) => structuredClone(getNodeById(id)));
          const edges = state.edges
            .filter((e) => ids.includes(e.s) && ids.includes(e.t))
            .map((e) => structuredClone(e));
          const minX = Math.min(...nodes.map((n) => n.x)),
            minY = Math.min(...nodes.map((n) => n.y));
          state.clip = { nodes, edges, dx: minX, dy: minY };
          setStatus("Copied selection");
        }
        function cutSelection() {
          copySelection();
          doDeleteSelection();
          setStatus("Cut selection");
        }
        function pasteClipboard(offsetBase = { x: 40, y: 40 }) {
          if (!state.clip) return;
          pushHistory();
          const offset = {
            x: offsetBase.x * (pasteCount + 1),
            y: offsetBase.y * (pasteCount + 1),
          };
          pasteCount++;
          const idMap = new Map();
          const pastedIds = [];
          for (const src of state.clip.nodes) {
            const id = uid();
            idMap.set(src.id, id);
            const clone = structuredClone(src);
            clone.id = id;
            clone.x = clone.x - state.clip.dx + offset.x;
            clone.y = clone.y - state.clip.dy + offset.y;
            state.nodes.push(clone);
            vocabInitNodeSnapshot(clone);
            vocabIngestNode(clone);
            mountNode(clone);
            measure(clone);
            positionNode(clone);
            populate(clone);
            pastedIds.push(id);
          }
          const newEdges = state.clip.edges.map((e) => ({
            s: idMap.get(e.s),
            t: idMap.get(e.t),
            dashed: !!e.dashed,
          }));
          state.edges.push(...newEdges);

          // sync MRU type
          vocab.typeMRU.removeIf((x) => {
            const k = normalizeToken(x || "");
            return !k || (counts.type.get(k) || 0) <= 0;
          });

          renderEdges();
          selectOnlyNodes(pastedIds);
          setStatus("Pasted");
        }
        function duplicateSelection() {
          if (!state.selNodes.size) return pasteClipboard({ x: 40, y: 40 });
        }
        function groupSelection() {
          if (!state.selNodes.size) return;
          pushHistory();
          const gid = state.groupSeq++;
          for (const id of state.selNodes) {
            const n = getNodeById(id);
            if (n) n.group = gid;
          }
          setStatus(`Grouped ${state.selNodes.size} node(s)`);
        }
        function ungroupSelection() {
          if (!state.selNodes.size) return;
          pushHistory();
          for (const id of state.selNodes) {
            const n = getNodeById(id);
            if (n) n.group = null;
          }
          setStatus("Ungrouped");
        }

        stage.addEventListener("dblclick", (e) => {
          if (!isBlankAtPoint(e.clientX, e.clientY)) return;
          const w = toWorld(e.clientX, e.clientY);
          addNodeAt(w.x, w.y);
        });

        async function ensureSubdir(dirHandle, name) {
          try {
            return await dirHandle.getDirectoryHandle(name, { create: true });
          } catch (e) {
            return await dirHandle.getDirectoryHandle(name, { create: false });
          }
        }
        function sanitizeName(name) {
          return (name || "file").replace(/[\\\/:*?"<>|]/g, "_");
        }
        async function writeFileByPath(root, relPath, blob) {
          const parts = relPath.split("/");
          const fileName = parts.pop();
          let dir = root;
          for (const seg of parts) {
            dir = await dir.getDirectoryHandle(seg, { create: true });
          }
          const fh = await dir.getFileHandle(fileName, { create: true });
          const w = await fh.createWritable();
          await w.write(blob);
          await w.close();
        }
        async function readFileByPath(root, relPath) {
          const parts = relPath.split("/");
          const fileName = parts.pop();
          let dir = root;
          for (const seg of parts) {
            dir = await dir.getDirectoryHandle(seg, { create: false });
          }
          const fh = await dir.getFileHandle(fileName, { create: false });
          const file = await fh.getFile();
          return file;
        }
        async function resizeImageBlob(
          blob,
          maxSide = 1500,
          targetBytes = 512 * 1024
        ) {
          const img = await blobToImage(blob);
          const { w, h } = fitWithin(
            img.naturalWidth || img.width,
            img.naturalHeight || img.height,
            maxSide
          );
          const canvas =
            "OffscreenCanvas" in window
              ? new OffscreenCanvas(w, h)
              : document.createElement("canvas");
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, w, h);
          let q = 0.92;
          let out = await canvasToBlob(canvas, "image/jpeg", q);
          while (out.size > targetBytes && q > 0.5) {
            q -= 0.08;
            out = await canvasToBlob(canvas, "image/jpeg", q);
          }
          return out;
        }
        function fitWithin(w, h, maxSide) {
          if (w >= h) {
            const s = maxSide / w;
            return { w: Math.round(w * s), h: Math.round(h * s) };
          } else {
            const s = maxSide / h;
            return { w: Math.round(w * s), h: Math.round(h * s) };
          }
        }
        function blobToImage(blob) {
          return new Promise((res, rej) => {
            const url = URL.createObjectURL(blob);
            const img = new Image();
            img.onload = () => {
              URL.revokeObjectURL(url);
              res(img);
            };
            img.onerror = rej;
            img.src = url;
          });
        }
        function canvasToBlob(canvas, type, quality) {
          return new Promise((res) => {
            if (canvas.convertToBlob) {
              canvas.convertToBlob({ type, quality }).then(res);
            } else {
              canvas.toBlob(res, type, quality);
            }
          });
        }
        function blobToDataURL(blob) {
          return new Promise((res) => {
            const r = new FileReader();
            r.onload = () => res(r.result);
            r.readAsDataURL(blob);
          });
        }
        function downloadBlob(filename, blob) {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            URL.revokeObjectURL(a.href);
            a.remove();
          }, 0);
        }
        function fileListToEntries(fileList) {
          const arr = Array.from(fileList || []);
          return arr.map((fl) => {
            const isImage = /^image\//i.test(fl.type);
            const isPDF =
              /pdf$/i.test(fl.type) || /\.pdf$/i.test(fl.name || "");
            const url = URL.createObjectURL(fl);
            return {
              name: fl.name,
              size: fl.size,
              type: fl.type,
              url,
              isImage,
              isPDF,
            };
          });
        }

        // Inizializzazione storia + primo nodo se necessario
        pushHistory();
        if (state.nodes.length === 0) {
          addNodeAt(80, 80, {});
        }

        resizeEdgeCanvasToStage();
        scheduleEdgeCanvasDraw();

        // Allinea subito eventuali anchor
        if (typeof scheduleEdgeCanvasDraw === "function")
          scheduleEdgeCanvasDraw();
        else renderEdges();
        /* ===== SAFE UNDO + HOTKEYS ROBUSTE + GATE CONNECT ===== */
        (function TS_SAFE_GUARD() {
          if (window.__TS_SAFE_GUARD__) return;
          window.__TS_SAFE_GUARD__ = true;

          const btnConnect = document.getElementById("btnConnect");
          const statusEl = document.getElementById("status");

          // status compatto con auto-hide (non tocco setStatus se già esiste)
          function status(msg) {
            try {
              if (typeof setStatus === "function") {
                setStatus(msg);
                return;
              }
              if (!statusEl) return;
              clearTimeout(status._t);
              statusEl.textContent = msg || "";
              if (msg)
                status._t = setTimeout(() => {
                  statusEl.textContent = "";
                }, 3000);
            } catch {}
          }

          // 1) Gate: il bottone Connect parte solo se c’è selezione
          if (btnConnect) {
            // capture = true per intercettare PRIMA di eventuali handler esistenti
            btnConnect.addEventListener(
              "click",
              (ev) => {
                const hasSel = (state?.selNodes?.size || 0) > 0;
                if (!hasSel) {
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  btnConnect.classList.remove("active"); // niente stato attivo
                  status("Select source node(s) first");
                }
              },
              true
            );
          }

          // 2) Hotkey robuste (usiamo e.code e capture per evitare conflitti a valle)
          let newNodeSeq = 0;
          const inText = () => {
            const el = document.activeElement;
            const tag = el?.tagName;
            return (
              tag === "INPUT" || tag === "TEXTAREA" || el?.isContentEditable
            );
          };

          window.addEventListener(
            "keydown",
            (e) => {
              if (inText()) return;

              const code = e.code; // fisico (KeyC, KeyA, ...)
              const shift = e.shiftKey;
              const meta = e.metaKey;
              const ctrl = e.ctrlKey;
              const alt = e.altKey;

              // Shift + A → Auto layout
              if (code === "KeyA" && shift && !meta && !ctrl && !alt) {
                e.preventDefault();
                try {
                  autoLayoutLeftToRight();
                  status("Auto layout");
                } catch {}
                return;
              }

              // Shift + C → attiva Connect SOLO se c’è selezione
              if (code === "KeyC" && shift && !meta && !ctrl && !alt) {
                e.preventDefault();
                const hasSel = (state?.selNodes?.size || 0) > 0;
                if (!hasSel) {
                  status("Select source node(s) first");
                  return;
                }
                // delega al bottone (così usa la tua logica attuale)
                btnConnect?.click();
                return;
              }

              // C → collega SUBITO 2 nodi selezionati (sinistra → destra)
              if (code === "KeyC" && !shift && !meta && !ctrl && !alt) {
                e.preventDefault();
                try {
                  const ids = [...(state?.selNodes || [])];
                  if (ids.length !== 2) {
                    status("Select exactly two nodes");
                    return;
                  }
                  const [a, b] = ids;
                  const na = state.nodes.find((n) => n.id === a);
                  const nb = state.nodes.find((n) => n.id === b);
                  if (!na || !nb) {
                    status("Nodes not found");
                    return;
                  }
                  const s = na.x <= nb.x ? a : b;
                  const t = na.x <= nb.x ? b : a;
                  if (state.edges.some((ed) => ed.s === s && ed.t === t)) {
                    status("No new connections");
                    return;
                  }
                  pushHistory();
                  addEdge(s, t);
                  renderEdges();
                  status("Connected");
                } catch {}
                return;
              }

              // U → apri chooser file se 1 nodo selezionato
              if (code === "KeyU" && !shift && !meta && !ctrl && !alt) {
                e.preventDefault();
                try {
                  if ((state?.selNodes?.size || 0) !== 1) {
                    status("Select one node first");
                    return;
                  }
                  document.getElementById("fFiles")?.click();
                  status("Choose files…");
                } catch {}
                return;
              }

              // N → nuovo nodo top-left della view con offset progressivo
              if (code === "KeyN" && !shift && !meta && !ctrl && !alt) {
                e.preventDefault();
                try {
                  const r = stage.getBoundingClientRect();
                  const base = toWorld(r.left + 80, r.top + 80);
                  addNodeAt(base.x + 40 * newNodeSeq, base.y + 40 * newNodeSeq);
                  newNodeSeq++;
                  status("New node created");
                } catch {}
                return;
              }
            },
            { capture: true }
          );
        })();

        /* =========================
         EDGE CLICKABILITY PATCH (HIT AREA SINCRONIZZATA)
         ========================= */

        /* 1) Inietta/aggiorna CSS per edge visibile + hit area ampia */
        (() => {
          const css = `
.edge-visible {
  stroke: #9a9a9a;
  stroke-width: 2;
  fill: none;
  cursor: pointer;
  pointer-events: stroke;
}
.edge-visible.selected {
  stroke: #ffffff;
  stroke-width: 3;
}
.edge-visible.weak {
  stroke: #9a9a9a;
  stroke-opacity: 0.5;
  stroke-dasharray: 10 6;
  stroke-linecap: round;
  stroke-width: 1.5;
}
.edge-visible.weak.selected {
  stroke: #ffffff;
  stroke-opacity: 1;
  stroke-dasharray: 10 6;
  stroke-linecap: round;
  stroke-width: 2.5;
}
/* Hit area invisibile ma larga, sempre cliccabile sullo stroke */
.edge-hit {
  stroke: transparent;
  stroke-width: 24;
  fill: none;
  cursor: pointer;
  pointer-events: stroke;
}`;
          let style = document.getElementById("edgeHitPatch");
          if (!style) {
            style = document.createElement("style");
            style.id = "edgeHitPatch";
            document.head.appendChild(style);
          }
          style.textContent = css;
        })();

        /* 2) Helper per aggiornare SEMPRE visibile + hit con lo stesso "d" */
        function __getEdgeGroupByIndex(i) {
          return edgesSVG.querySelector(`g[data-idx="${i}"]`);
        }
        function __updateEdgePaths(i, d) {
          const g = __getEdgeGroupByIndex(i);
          if (!g) return;
          const pv = g.querySelector("path.edge-visible");
          const ph = g.querySelector("path.edge-hit");
          if (pv) pv.setAttribute("d", d);
          if (ph) ph.setAttribute("d", d);
        }

        /* 3) Sostituisci renderEdges con una versione che crea SEMPRE entrambi i path
            e assegna data-idx per gli update mirati */
        const __origRenderEdgesRef = renderEdges;
        renderEdges = function renderEdges() {
          ensureSVGSize();
          edgesSVG.innerHTML = "";

          state.edges.forEach((e, i) => {
            const s = anchor(e.s, "right");
            const t = anchor(e.t, "left");
            if (!s || !t) return;

            const g = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            g.setAttribute("data-idx", String(i));
            const d = pathCubic(s, t);

            // Hit area (sotto)
            const ph = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            ph.setAttribute("class", "edge-hit");
            ph.setAttribute("d", d);
            g.appendChild(ph);

            // Visibile (sopra)
            const pv = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            pv.setAttribute(
              "class",
              "edge-visible" + (e.dashed ? " weak" : "")
            );
            pv.setAttribute("d", d);
            if (state.selEdges.has(i)) pv.classList.add("selected");
            g.appendChild(pv);

            // Click su gruppo (vale per hit + visibile)
            g.addEventListener("click", (ev) => {
              ev.stopPropagation();
              if (ev.altKey) {
                // split edge in due con nodo intermedio
                pushHistory();
                const mid = { x: (s.x + t.x) / 2, y: (s.y + t.y) / 2 };
                const nid = addNodeAt(
                  mid.x - NODE_W / 2,
                  mid.y - NODE_H / 2,
                  {}
                );
                const dashed = !!e.dashed;
                state.edges.splice(i, 1);
                state.edges.push(
                  { s: e.s, t: nid, dashed },
                  { s: nid, t: e.t, dashed }
                );
                renderEdges();
                return;
              }
              if (ev.shiftKey) toggleEdgeSelection(i);
              else selectOnlyEdges([i]);
            });

            edgesSVG.appendChild(g);
          });

          // Ghost link mentre trascini per creare un edge
          if (state.dragLink && state.dragLink.active) {
            const t = { x: state.dragLink.x, y: state.dragLink.y };
            for (const sid of state.dragLink.sources) {
              const fromAnchor =
                state.dragLink.from === "out"
                  ? anchor(sid, "right")
                  : anchor(sid, "left");
              const a = state.dragLink.from === "out" ? fromAnchor : t;
              const b = state.dragLink.from === "out" ? t : fromAnchor;
              const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );
              path.setAttribute("d", pathCubic(a, b));
              path.setAttribute("stroke", "#fff");
              path.setAttribute("stroke-width", "2");
              path.setAttribute("fill", "none");
              edgesSVG.appendChild(path);
            }
          }
        };

        /* 4) Ogni volta che un nodo viene riposizionato, aggiorna SOLO gli edge collegati
            (wrappiamo positionNode per non toccare i tuoi handler di drag) */
        const __origPositionNodeRef = positionNode;
        positionNode = function patchedPositionNode(node) {
          __origPositionNodeRef(node);
          // aggiorna tutti gli edge collegati al nodo
          for (let i = 0; i < state.edges.length; i++) {
            const ed = state.edges[i];
            if (ed.s === node.id || ed.t === node.id) {
              const s = anchor(ed.s, "right");
              const t = anchor(ed.t, "left");
              if (!s || !t) continue;
              __updateEdgePaths(i, pathCubic(s, t));
            }
          }
        };
      })(); // chiusura dell'IIFE

      const toolbarTooltips = [
        { id: "btnAdd", label: "Add node (N)" },
        { id: "btnDel", label: "Delete selection (⌫)" },
        { id: "btnFit", label: "Fit view (0)" },
        { id: "btnAuto", label: "Auto layout (⇧A)" },
        { id: "btnOpen", label: "Open project (⌘O)" },
        { id: "btnSave", label: "Save project (⌘S)" },
        { id: "btnNew", label: "New project" },
        { id: "btnConnect", label: "Connect nodes" },
        { id: "btnUndo", label: "Undo (⌘Z)" },
        { id: "btnRedo", label: "Redo (⌘⇧Z)" },
      ];

      document.querySelectorAll("header button").forEach((btn) => {
        const def = toolbarTooltips.find((t) => t.id === btn.id);
        if (def) btn.setAttribute("data-tip", def.label);
      });

      // Help overlay (clone .doc-section → modal)
      (function setupHelpOverlay() {
        function init() {
          const overlay = document.getElementById("helpOverlay");
          const content = document.getElementById("helpContent");
          const btnHelp = document.getElementById("btnHelp");
          const btnClose = document.getElementById("helpClose");
          const toolbarBtns = Array.from(
            document.querySelectorAll("header button")
          );

          if (!overlay || !content || !btnHelp) return;

          function collectDocSections() {
            return Array.from(document.querySelectorAll(".doc-section"));
          }

          function openHelp() {
            if (!content.dataset.filled) {
              const sections = collectDocSections();
              if (sections.length) {
                sections.forEach((sec) => {
                  const clone = sec.cloneNode(true);
                  content.appendChild(clone);
                  sec.style.display = "none";
                });
                content.dataset.filled = "1";
              } else {
                content.innerHTML =
                  '<p style="margin:0">Documentation not found in DOM.</p>';
                content.dataset.filled = "1";
              }
            }
            overlay.style.display = "block";
          }

          function closeHelp() {
            overlay.style.display = "none";
          }

          btnHelp.addEventListener(
            "click",
            (e) => {
              e.preventDefault();
              e.stopPropagation();
              openHelp();
            },
            { capture: true }
          );

          btnClose?.addEventListener("click", (e) => {
            e.preventDefault();
            closeHelp();
          });

          overlay.addEventListener("click", () => closeHelp());
          overlay
            .querySelector(".doc-box")
            ?.addEventListener("click", (e) => e.stopPropagation());

          toolbarBtns.forEach((btn) => {
            if (btn && btn !== btnHelp) {
              btn.addEventListener("click", () => closeHelp(), {
                capture: true,
              });
            }
          });

          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && overlay.style.display === "block")
              closeHelp();
          });
        }

        if (document.getElementById("helpOverlay")) init();
        else document.addEventListener("DOMContentLoaded", init);
      })();
    </script>
    <script>
      /* No tooltip su Upload files */
      document.getElementById("btnChoose")?.removeAttribute("title");
    </script>
    <div id="helpOverlay" style="display: none">
      <div class="doc-box">
        <div class="doc-box-header">
          <span class="material-symbols-outlined">help</span>
          <div class="doc-title">Threadscape — Documentation</div>
          <button id="helpClose" class="icon-btn" aria-label="Close">
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <div class="doc-box-body" id="helpContent"></div>
      </div>
    </div>
  </body>
</html>
